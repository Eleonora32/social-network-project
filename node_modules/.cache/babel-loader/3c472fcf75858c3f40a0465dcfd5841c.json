{"ast":null,"code":"import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';\nimport _extends from '@babel/runtime/helpers/extends';\nimport { useRef, useReducer, useCallback, useEffect, useState as useState$1 } from 'react';\nimport { dequal } from 'dequal/lite';\nvar one;\nvar all = {};\n\nvar get$1 = function get(id) {\n  return id ? all[id] : one;\n};\n\nvar set$1 = function set(id, methods) {\n  if (id) {\n    all[id] = methods;\n  } else {\n    one = methods;\n  }\n};\n\nvar remove = function remove(id) {\n  if (id) {\n    delete all[id];\n  } else {\n    one = undefined;\n  }\n};\n\nvar useLatest = function (val) {\n  var ref = useRef(val);\n  ref.current = val;\n  return ref;\n};\n\nvar arrayToMap = function (arr, map) {\n  if (map === void 0) {\n    map = {};\n  }\n\n  return arr.reduce(function (obj, key) {\n    obj[map[key] || key] = true;\n    return obj;\n  }, {});\n};\n\nvar isFileList = function (value) {\n  return value instanceof FileList;\n};\n\nvar isObject = function (value) {\n  return value !== null && typeof value === \"object\";\n};\n\nvar cloneObject = function cloneObject(object) {\n  if (object instanceof Event) throw new Error(\"Unable to clone event.\");\n  if (!isObject(object) || isFileList(object)) return object;\n  if (object instanceof Date) return new Date(object.getTime());\n  if (Array.isArray(object)) return object.map(function (val) {\n    return cloneObject(val);\n  });\n  return Object.keys(object).reduce(function (obj, key) {\n    obj[key] = cloneObject(object[key]);\n    return obj;\n  }, {});\n};\n\nvar compact = function (arr) {\n  return arr.filter(Boolean);\n};\n\nvar isPlainObject = function (value) {\n  return !Array.isArray(value) && !(value instanceof Date) && isObject(value);\n};\n\nvar deepMerge = function deepMerge() {\n  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\n    objects[_key] = arguments[_key];\n  }\n\n  return objects.reduce(function (prev, obj) {\n    Object.keys(obj).forEach(function (key) {\n      var prevValue = prev[key];\n      var currValue = obj[key];\n\n      if (Array.isArray(prevValue) && Array.isArray(currValue)) {\n        prev[key] = [].concat(prevValue, currValue);\n      } else if (isPlainObject(prevValue) && isPlainObject(currValue)) {\n        prev[key] = deepMerge(prevValue, currValue);\n      } else {\n        prev[key] = currValue;\n      }\n    });\n    return prev;\n  }, {});\n};\n\nvar isUndefined = function (value) {\n  return value === undefined;\n};\n\nvar filterErrors = function filterErrors(error, touched) {\n  if (!isPlainObject(error)) return touched ? error : undefined;\n  return Object.keys(error).reduce(function (obj, key) {\n    var nextErrors = filterErrors(error[key], touched[key] || false);\n\n    if (!isUndefined(nextErrors)) {\n      obj[key] = nextErrors;\n    } else {\n      delete obj[key];\n    }\n\n    return obj;\n  }, {});\n};\n\nvar stringToPath = function (str) {\n  if (typeof str !== \"string\") throw new TypeError(\"Expected a string.\");\n  if (!str.length) return [];\n  return compact(str.split(/[.[\\]]+/));\n};\n\nvar get = function (object, path, defaultValue) {\n  if (!isPlainObject(object) || !path) return defaultValue;\n  var value = stringToPath(path).reduce(function (obj, key) {\n    return (obj || {})[key];\n  }, object);\n  return !isUndefined(value) ? value : defaultValue;\n};\n\nvar getIsDirty = function (dirty) {\n  var search = function search(dty, found) {\n    if (found === void 0) {\n      found = [];\n    }\n\n    for (var _i = 0, _Object$values = Object.values(dty); _i < _Object$values.length; _i++) {\n      var val = _Object$values[_i];\n\n      if (val === true) {\n        found.push(val);\n        return found;\n      }\n\n      if (isObject(val)) search(val, found);\n    }\n\n    return found;\n  };\n\n  return !!search(dirty).length;\n};\n\nvar getPath = function (path) {\n  return ![\"values\", \"touched\", \"errors\", \"isDirty\", \"dirty\", \"isValidating\", \"isValid\", \"isSubmitting\", \"isSubmitted\", \"submitCount\"].some(function (key) {\n    return path.startsWith(key);\n  }) ? \"values.\" + path : path;\n};\n\nvar invariant = function (condition, message) {\n  if (process.env.NODE_ENV !== \"production\" && condition) throw new Error(message);\n};\n\nvar isFunction = function (value) {\n  return typeof value === \"function\";\n};\n\nvar isAsyncFunction = function (value) {\n  return isFunction(value) && value.constructor.name === \"AsyncFunction\";\n};\n\nvar isCheckboxInput = function (field) {\n  return field.type === \"checkbox\";\n};\n\nvar isEmptyObject = function (value) {\n  return isPlainObject(value) && !Object.keys(value).length;\n};\n\nvar isFieldArray = function (fields, name, callback) {\n  var fieldName;\n  Object.keys(fields).some(function (key) {\n    if (name.startsWith(key)) {\n      fieldName = key;\n      if (callback) callback(key);\n      return true;\n    }\n\n    return false;\n  });\n  return fieldName;\n};\n\nvar isFieldElement = function (element) {\n  return /INPUT|TEXTAREA|SELECT/.test(element.tagName);\n};\n\nvar isFileInput = function (field) {\n  return field.type === \"file\";\n};\n\nvar isInputElement = function (element) {\n  return element.tagName === \"INPUT\";\n};\n\nvar isNumberInput = function (field) {\n  return field.type === \"number\";\n};\n\nvar isRadioInput = function (field) {\n  return field.type === \"radio\";\n};\n\nvar isRangeInput = function (field) {\n  return field.type === \"range\";\n};\n\nvar isSelectMultiple = function (field) {\n  return field.type === \"select-multiple\";\n};\n\nvar isSelectOne = function (field) {\n  return field.type === \"select-one\";\n};\n\nvar parseState = function (path, state, pathHandler, stateHandler, isGetState) {\n  if (pathHandler === void 0) {\n    pathHandler = getPath;\n  }\n\n  if (!path) return isGetState ? state : undefined;\n  var parsedState;\n\n  if (Array.isArray(path)) {\n    parsedState = path.map(function (p) {\n      p = pathHandler(p);\n      var value = get(state, p);\n      return stateHandler ? stateHandler(p, value) : value;\n    });\n  } else if (isPlainObject(path)) {\n    var paths = path;\n    parsedState = Object.keys(paths).reduce(function (s, key) {\n      path = pathHandler(paths[key]);\n      var value = get(state, path);\n      s[key] = stateHandler ? stateHandler(path, value) : value;\n      return s;\n    }, {});\n  } else {\n    path = pathHandler(path);\n    var value = get(state, path);\n    parsedState = stateHandler ? stateHandler(path, value) : value;\n  }\n\n  return parsedState;\n};\n\nvar runWithLowPriority = function (callback) {\n  return (window.requestIdleCallback || function (cb) {\n    var start = Date.now();\n    return setTimeout(function () {\n      return cb({\n        didTimeout: false,\n        timeRemaining:\n        /* istanbul ignore next */\n        function timeRemaining() {\n          return Math.max(0, 50 - (Date.now() - start));\n        }\n      });\n    }, 1);\n  })(callback, {\n    timeout: 2000\n  });\n};\n\nvar set = function (object, path, value, immutable) {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n  var newObject = immutable ? cloneObject(object) : object;\n  var segs = stringToPath(path);\n  segs.slice(0, -1).reduce(function (obj, key, idx) {\n    var nextIsNumber = !Number.isNaN(+segs[idx + 1]);\n    if (isPlainObject(obj[key]) && !nextIsNumber || Array.isArray(obj[key]) && nextIsNumber) return obj[key];\n    obj[key] = nextIsNumber ? [] : {};\n    return obj[key];\n  }, newObject)[segs[segs.length - 1] || \"\"] = value;\n  return newObject;\n};\n\nvar setValuesAsTrue = function setValuesAsTrue(object) {\n  if (!Array.isArray(object) && !isPlainObject(object)) return true;\n  if (Array.isArray(object)) return object.map(function (val) {\n    return setValuesAsTrue(val);\n  });\n  return Object.keys(object).reduce(function (obj, key) {\n    obj[key] = setValuesAsTrue(object[key]);\n    return obj;\n  }, {});\n};\n\nvar unset = function unset(object, path, immutable) {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n  var refObject = immutable ? cloneObject(object) : object;\n  var newObject = refObject; // eslint-disable-next-line no-prototype-builtins\n\n  if (newObject.hasOwnProperty(path)) {\n    delete newObject[path];\n    return refObject;\n  }\n\n  var segs = stringToPath(path);\n  if (!segs.length) return refObject;\n  var last = segs.pop();\n  var target = segs.reduce(function (obj, key) {\n    return (obj || {})[key];\n  }, newObject);\n\n  if (Array.isArray(target)) {\n    var index = +last;\n\n    if (index < target.length - 1) {\n      delete target[index];\n    } else {\n      while (index >= 0) {\n        // @ts-expect-error\n        if (index == last || isUndefined(target[index])) {\n          target.splice(index, 1);\n          index -= 1;\n        } else {\n          break;\n        }\n      }\n    }\n  } else if (isPlainObject(target)) {\n    delete target[last];\n  }\n\n  return isEmptyObject(target) || Array.isArray(target) && !target.filter(function (t) {\n    return !isUndefined(t);\n  }).length ? unset(refObject, segs.join(\".\")) : refObject;\n};\n\nvar warn = function () {\n  var _console;\n\n  if (process.env.NODE_ENV !== \"production\") (_console = console).warn.apply(_console, arguments);\n};\n\nvar useState = function (initialState, onChange) {\n  var _useReducer = useReducer(function (c) {\n    return c + 1;\n  }, 0),\n      forceUpdate = _useReducer[1];\n\n  var stateRef = useRef(initialState);\n  var observersRef = useRef([{\n    usedState: {},\n    notify: forceUpdate\n  }]);\n  var onChangeRef = useLatest(onChange || function () {\n    return undefined;\n  });\n  var setStateRef = useCallback(function (path, value, _temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        fieldPath = _ref.fieldPath,\n        shouldSkipUpdate = _ref.shouldSkipUpdate,\n        shouldForceUpdate = _ref.shouldForceUpdate;\n\n    var key = path.split(\".\")[0];\n\n    if (!key) {\n      if (!dequal(stateRef.current, value)) {\n        stateRef.current = value;\n        onChangeRef.current(stateRef.current);\n        observersRef.current.forEach(function (_ref2) {\n          var usedState = _ref2.usedState,\n              notify = _ref2.notify;\n          return !isEmptyObject(usedState) && notify(stateRef.current);\n        });\n      }\n\n      return;\n    }\n\n    if (path !== \"values\" && key === \"values\" || !dequal(get(stateRef.current, path), value)) {\n      var state = set(stateRef.current, path, value, true);\n      var errors = state.errors,\n          dirty = state.dirty,\n          prevIsDirty = state.isDirty,\n          prevIsValid = state.isValid,\n          prevSubmitCount = state.submitCount;\n      var currSubmitCount = state.submitCount;\n      var isDirty = key === \"dirty\" ? getIsDirty(dirty) : prevIsDirty;\n      var isValid = key === \"errors\" ? isEmptyObject(errors) : prevIsValid;\n      var submitCount = key === \"isSubmitting\" && value ? currSubmitCount += 1 : currSubmitCount;\n      stateRef.current = _extends({}, state, {\n        isDirty: isDirty,\n        isValid: isValid,\n        submitCount: submitCount\n      });\n      onChangeRef.current(stateRef.current);\n      if (shouldSkipUpdate) return;\n      path = fieldPath || path;\n      observersRef.current.forEach(function (_ref3) {\n        var usedState = _ref3.usedState,\n            notify = _ref3.notify;\n        return (shouldForceUpdate || Object.keys(usedState).some(function (k) {\n          return path.startsWith(k) || k.startsWith(path);\n        }) || usedState.isDirty && isDirty !== prevIsDirty || usedState.isValid && isValid !== prevIsValid || usedState.submitCount && submitCount !== prevSubmitCount) && notify(stateRef.current);\n      });\n    }\n  }, [onChangeRef]);\n  return {\n    stateRef: stateRef,\n    setStateRef: setStateRef,\n    observersRef: observersRef\n  };\n};\n\nvar _excluded$1 = [\"defaultValue\"],\n    _excluded2$1 = [\"validate\"];\n\nvar useForm = function (_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      id = _ref.id,\n      _ref$defaultValues = _ref.defaultValues,\n      defaultValues = _ref$defaultValues === void 0 ? {} : _ref$defaultValues,\n      validate = _ref.validate,\n      _ref$validateOnChange = _ref.validateOnChange,\n      validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange,\n      _ref$validateOnBlur = _ref.validateOnBlur,\n      validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur,\n      _ref$focusOnError = _ref.focusOnError,\n      focusOnError = _ref$focusOnError === void 0 ? true : _ref$focusOnError,\n      _ref$removeOnUnmounte = _ref.removeOnUnmounted,\n      removeOnUnmounted = _ref$removeOnUnmounte === void 0 ? true : _ref$removeOnUnmounte,\n      _ref$builtInValidatio = _ref.builtInValidationMode,\n      builtInValidationMode = _ref$builtInValidatio === void 0 ? \"message\" : _ref$builtInValidatio,\n      _ref$excludeFields = _ref.excludeFields,\n      excludeFields = _ref$excludeFields === void 0 ? [] : _ref$excludeFields,\n      onReset = _ref.onReset,\n      onSubmit = _ref.onSubmit,\n      onError = _ref.onError,\n      onStateChange = _ref.onStateChange;\n\n  var handlersRef = useRef({});\n  var mutationObserverRef = useRef();\n  var formRef = useRef();\n  var fieldsRef = useRef(new Map());\n  var fieldParsersRef = useRef({});\n  var fieldArrayRef = useRef({});\n  var controlsRef = useRef({});\n  var formValidatorRef = useLatest(validate);\n  var fieldValidatorsRef = useRef({});\n  var changedFieldRef = useRef();\n  var excludeFieldsRef = useRef(arrayToMap(excludeFields));\n  var onResetRef = useLatest(onReset || function () {\n    return undefined;\n  });\n  var onSubmitRef = useLatest(onSubmit || function () {\n    return undefined;\n  });\n  var onErrorRef = useLatest(onError || function () {\n    return undefined;\n  });\n  var hasWarnValues = useRef(false);\n  var initialStateRef = useRef({\n    values: defaultValues,\n    touched: {},\n    errors: {},\n    isDirty: false,\n    dirty: {},\n    isValidating: false,\n    isValid: true,\n    isSubmitting: false,\n    isSubmitted: false,\n    submitCount: 0\n  });\n\n  var _useState = useState(initialStateRef.current, onStateChange),\n      stateRef = _useState.stateRef,\n      setStateRef = _useState.setStateRef,\n      observersRef = _useState.observersRef;\n\n  var handleUnset = useCallback(function (path, options) {\n    var segs = path.split(\".\");\n    var k = segs.shift();\n    setStateRef(k, unset(stateRef.current[k], segs.join(\".\"), true), _extends({\n      fieldPath: path\n    }, options));\n  }, [setStateRef, stateRef]);\n  var getFields = useCallback(function (form) {\n    return Array.from(form.querySelectorAll(\"input,textarea,select\")).filter(function (element) {\n      var field = element;\n      var type = field.type,\n          name = field.name,\n          fieldId = field.id,\n          classList = field.classList,\n          rcfExclude = field.dataset.rcfExclude;\n      var exclude = excludeFieldsRef.current;\n      if (/button|image|submit|reset/.test(type) || fieldId && exclude[\"#\" + fieldId] || Array.from(classList).find(function (n) {\n        return exclude[\".\" + n];\n      })) return false;\n\n      if (rcfExclude !== \"true\" && !name) {\n        warn('ðŸ’¡ react-cool-form > field: Missing \"name\" attribute. Do you want to exclude the field? See: https://react-cool-form.netlify.app/docs/api-reference/use-form/#excludefields');\n        return false;\n      }\n\n      return controlsRef.current[name] || rcfExclude !== \"true\" && !exclude[name];\n    }).reduce(function (acc, elm) {\n      var _acc$get;\n\n      var field = elm;\n      var name = field.name;\n      var fieldArrayName = isFieldArray(fieldArrayRef.current, name);\n      if (fieldArrayName) fieldArrayRef.current[fieldArrayName].fields[name] = true;\n      acc.set(name, _extends({}, acc.get(name), {\n        field: ((_acc$get = acc.get(name)) == null ? void 0 : _acc$get.field) || field\n      }));\n\n      if (isCheckboxInput(field) || isRadioInput(field)) {\n        acc.get(name).options = acc.get(name).options ? [].concat(acc.get(name).options, [field]) : [field];\n      } else if (isSelectOne(field) || isSelectMultiple(field)) {\n        acc.get(name).options = Array.from(field.options);\n      }\n\n      return acc;\n    }, new Map());\n  }, []);\n  var getNodeValue = useCallback(function (name, fields) {\n    var _find;\n\n    if (fields === void 0) {\n      fields = fieldsRef.current;\n    }\n\n    if (!fields.has(name)) return undefined;\n\n    var _ref2 = fields.get(name),\n        field = _ref2.field,\n        options = _ref2.options;\n\n    if (isInputElement(field)) {\n      var _fieldParsersRef$curr, _fieldParsersRef$curr2;\n\n      if ((_fieldParsersRef$curr = fieldParsersRef.current[name]) != null && _fieldParsersRef$curr.valueAsNumber) return field.valueAsNumber;\n      if ((_fieldParsersRef$curr2 = fieldParsersRef.current[name]) != null && _fieldParsersRef$curr2.valueAsDate) return field.valueAsDate;\n    }\n\n    if (isNumberInput(field) || isRangeInput(field)) return field.valueAsNumber || \"\";\n\n    if (isCheckboxInput(field)) {\n      var checkboxes = options;\n      if (checkboxes.length > 1) return checkboxes.filter(function (c) {\n        return c.checked;\n      }).map(function (c) {\n        return c.value;\n      });\n      var checkbox = checkboxes[0];\n      if (checkbox.hasAttribute(\"value\") && checkbox.value) return checkbox.checked ? [checkbox.value] : [];\n      return checkbox.checked;\n    }\n\n    if (isRadioInput(field)) return ((_find = options.find(function (radio) {\n      return radio.checked;\n    })) == null ? void 0 : _find.value) || \"\";\n    if (isSelectMultiple(field)) return options.filter(function (option) {\n      return option.selected;\n    }).map(function (option) {\n      return option.value;\n    });\n    if (isFileInput(field)) return field.files;\n    return field.value;\n  }, []);\n  var setNodeValue = useCallback(function (name, value, fields) {\n    if (fields === void 0) {\n      fields = fieldsRef.current;\n    }\n\n    if (!fields.has(name) || controlsRef.current[name]) return;\n\n    var _ref3 = fields.get(name),\n        field = _ref3.field,\n        options = _ref3.options;\n\n    if (isCheckboxInput(field)) {\n      var checkboxes = options;\n\n      if (checkboxes.length > 1) {\n        checkboxes.forEach(function (checkbox) {\n          checkbox.checked = Array.isArray(value) ? value.includes(checkbox.value) : !!value;\n        });\n      } else {\n        checkboxes[0].checked = !!value;\n      }\n    } else if (isRadioInput(field)) {\n      options.forEach(function (radio) {\n        radio.checked = radio.value === value;\n      });\n    } else if (isSelectMultiple(field) && Array.isArray(value)) {\n      options.forEach(function (option) {\n        option.selected = !!value.includes(option.value);\n      });\n    } else if (isFileInput(field)) {\n      if (isFileList(value)) field.files = value;\n      if (!value) field.value = \"\";\n    } else {\n      field.value = value != null ? value : \"\";\n    }\n  }, []);\n  var setDefaultValue = useCallback(function (name, value, shouldUpdateDefaultValue) {\n    if (shouldUpdateDefaultValue === void 0) {\n      shouldUpdateDefaultValue = !isFieldArray(fieldArrayRef.current, name) || !isUndefined(get(initialStateRef.current.values, name.split(\".\")[0]));\n    }\n\n    if (shouldUpdateDefaultValue) initialStateRef.current.values = set(initialStateRef.current.values, name, value, true);\n    if (!dequal(get(stateRef.current.values, name), value)) setStateRef(\"values.\" + name, value, {\n      shouldSkipUpdate: true\n    });\n  }, [setStateRef, stateRef]);\n  var setNodesOrValues = useCallback(function (values, _temp2) {\n    var _ref4 = _temp2 === void 0 ? {} : _temp2,\n        _ref4$shouldSetValues = _ref4.shouldSetValues,\n        shouldSetValues = _ref4$shouldSetValues === void 0 ? true : _ref4$shouldSetValues,\n        _ref4$fields = _ref4.fields,\n        fields = _ref4$fields === void 0 ? Array.from(fieldsRef.current.keys()) : _ref4$fields;\n\n    return fields.forEach(function (name) {\n      if (controlsRef.current[name]) return;\n      var value = get(values, name);\n      if (!isUndefined(value)) setNodeValue(name, value);\n      if (shouldSetValues) setDefaultValue(name, !isUndefined(value) ? value : getNodeValue(name));\n    });\n  }, [getNodeValue, setDefaultValue, setNodeValue]);\n  var setError = useCallback(function (name, error) {\n    error = isFunction(error) ? error(get(stateRef.current.errors, name)) : error;\n\n    if (error) {\n      setStateRef(\"errors.\" + name, error);\n    } else {\n      handleUnset(\"errors.\" + name);\n    }\n  }, [handleUnset, setStateRef, stateRef]);\n  var clearErrors = useCallback(function (name) {\n    if (!name) {\n      setStateRef(\"errors\", {});\n    } else if (Array.isArray(name)) {\n      name.forEach(function (n) {\n        return setError(n);\n      });\n    } else {\n      setError(name);\n    }\n  }, [setError, setStateRef]);\n  var runBuiltInValidation = useCallback(function (name) {\n    if (builtInValidationMode === false || !fieldsRef.current.has(name)) return undefined;\n\n    var _ref5 = fieldsRef.current.get(name),\n        _ref5$field = _ref5.field,\n        validity = _ref5$field.validity,\n        validationMessage = _ref5$field.validationMessage;\n\n    if (builtInValidationMode === \"state\") for (var k in validity) {\n      if (k !== \"valid\" && validity[k]) return k;\n    }\n    return validationMessage;\n  }, [builtInValidationMode]);\n  var runAllBuiltInValidation = useCallback(function () {\n    if (builtInValidationMode === false) return {};\n    return Array.from(fieldsRef.current.keys()).reduce(function (errors, name) {\n      var error = runBuiltInValidation(name);\n      errors = _extends({}, errors, error ? set(errors, name, error) : {});\n      return errors;\n    }, {});\n  }, [builtInValidationMode, runBuiltInValidation]);\n  var runFieldValidation = useCallback(async function (name) {\n    var value = get(stateRef.current.values, name);\n    if (!fieldValidatorsRef.current[name] || isUndefined(value)) return undefined;\n\n    try {\n      var error = await fieldValidatorsRef.current[name](value, stateRef.current.values);\n      return error;\n    } catch (exception) {\n      warn(\"\\uD83D\\uDCA1 react-cool-form > validate \" + name + \": \", exception);\n      throw exception;\n    }\n  }, [stateRef]);\n  var runAllFieldsValidation = useCallback(function () {\n    var promises = Object.keys(fieldValidatorsRef.current).map(function (name) {\n      return runFieldValidation(name);\n    });\n    return Promise.all(promises).then(function (errors) {\n      return Object.keys(fieldValidatorsRef.current).reduce(function (acc, cur, idx) {\n        acc = _extends({}, acc, errors[idx] ? set(acc, cur, errors[idx]) : {});\n        return acc;\n      }, {});\n    });\n  }, [runFieldValidation]);\n  var runFormValidation = useCallback(async function (name) {\n    if (!formValidatorRef.current) return name ? undefined : {};\n\n    try {\n      var errors = await formValidatorRef.current(stateRef.current.values);\n      if (name) return get(errors, name);\n      return isPlainObject(errors) ? errors : {};\n    } catch (exception) {\n      warn(\"\\uD83D\\uDCA1 react-cool-form > validate form: \", exception);\n      throw exception;\n    }\n  }, [formValidatorRef, stateRef]);\n  var validateField = useCallback(async function (name) {\n    var hasAsyncValidator = isAsyncFunction(formValidatorRef.current) || isAsyncFunction(fieldValidatorsRef.current[name]);\n    if (hasAsyncValidator) setStateRef(\"isValidating\", true);\n\n    try {\n      var error = (await runFormValidation(name)) || (await runFieldValidation(name)) || runBuiltInValidation(name);\n      setError(name, error);\n      if (hasAsyncValidator) setStateRef(\"isValidating\", false);\n      return error;\n    } catch (exception) {\n      return exception;\n    }\n  }, [formValidatorRef, runBuiltInValidation, runFieldValidation, runFormValidation, setError, setStateRef]);\n  var validateFieldWithLowPriority = useCallback(function (name) {\n    return runWithLowPriority(function () {\n      return validateField(name);\n    });\n  }, [validateField]);\n  var validateForm = useCallback(function () {\n    setStateRef(\"isValidating\", true);\n    return Promise.all([runAllBuiltInValidation(), runAllFieldsValidation(), runFormValidation()]).then(function (errors) {\n      var errs = deepMerge.apply(void 0, errors);\n      setStateRef(\"errors\", errs);\n      setStateRef(\"isValidating\", false);\n      return errs;\n    });\n  }, [runAllBuiltInValidation, runAllFieldsValidation, runFormValidation, setStateRef]);\n  var runValidation = useCallback(function (name) {\n    if (!name) return validateForm().then(function (errors) {\n      return isEmptyObject(errors);\n    });\n    if (Array.isArray(name)) return Promise.all(name.map(function (n) {\n      return validateField(n);\n    })).then(function (errors) {\n      return !compact(errors).length;\n    });\n    return validateField(name).then(function (error) {\n      return !error;\n    });\n  }, [validateField, validateForm]);\n  var getFormState = useCallback(function (path, _temp3) {\n    var _ref6 = _temp3 === void 0 ? {} : _temp3,\n        errorWithTouched = _ref6.errorWithTouched,\n        _ref6$defaultValues = _ref6.defaultValues,\n        dfValues = _ref6$defaultValues === void 0 ? {} : _ref6$defaultValues,\n        _ref6$methodName = _ref6.methodName,\n        methodName = _ref6$methodName === void 0 ? \"getState\" : _ref6$methodName,\n        callback = _ref6.callback;\n\n    var usedState = {};\n    var state = parseState(path, stateRef.current, function (p) {\n      p = getPath(p);\n\n      if (methodName !== \"getState\") {\n        if (p === \"values\" && methodName !== \"useFormStateCallback\" && !hasWarnValues.current) {\n          warn(\"\\uD83D\\uDCA1 react-cool-form > \" + methodName + \": Getting \\\"values\\\" alone might cause unnecessary re-renders. If you know what you're doing, just ignore this warning. See: https://react-cool-form.netlify.app/docs/getting-started/form-state#best-practices\");\n          hasWarnValues.current = true;\n        }\n\n        usedState[p] = true;\n      }\n\n      return p;\n    }, function (p, v) {\n      if (methodName === \"getState\") return v;\n\n      if (p.startsWith(\"values\")) {\n        if (!isUndefined(v)) return v;\n        p = p.replace(\"values.\", \"\");\n        v = get(initialStateRef.current, p);\n        return !isUndefined(v) ? v : get(dfValues, p);\n      }\n\n      if (!errorWithTouched || !p.startsWith(\"errors\")) return v;\n      p = p.replace(\"errors\", \"touched\");\n      usedState[p] = true;\n      return filterErrors(v, get(stateRef.current, p));\n    }, methodName === \"getState\");\n    if (callback) callback(usedState);\n    return state;\n  }, [stateRef]);\n  var handleFocus = useCallback(function (name) {\n    var _fieldsRef$current$ge, _fieldsRef$current$ge2;\n\n    var field = ((_fieldsRef$current$ge = fieldsRef.current.get(name)) == null ? void 0 : _fieldsRef$current$ge.field) || ((_fieldsRef$current$ge2 = fieldsRef.current.get(Array.from(fieldsRef.current.keys()).find(function (n) {\n      return n.startsWith(name);\n    }) || \"\")) == null ? void 0 : _fieldsRef$current$ge2.field);\n    if (field && isFunction(field.focus)) field.focus();\n  }, []);\n  var focus = useCallback(function (name, delay) {\n    if (!isUndefined(delay)) {\n      setTimeout(function () {\n        return handleFocus(name);\n      }, delay);\n    } else {\n      handleFocus(name);\n    }\n  }, [handleFocus]);\n  var use = useCallback(function (path, _temp4) {\n    var _ref7 = _temp4 === void 0 ? {} : _temp4,\n        errorWithTouched = _ref7.errorWithTouched,\n        dfValues = _ref7.defaultValues;\n\n    return getFormState(path, {\n      errorWithTouched: errorWithTouched,\n      defaultValues: dfValues,\n      methodName: \"use\",\n      callback: function callback(usedState) {\n        observersRef.current[0].usedState = _extends({}, observersRef.current[0].usedState, usedState);\n      }\n    });\n  }, [getFormState, observersRef]);\n  var getState = useCallback(function (path) {\n    return getFormState(path);\n  }, [getFormState]);\n  var setTouched = useCallback(function (name, isTouched, _temp5) {\n    if (isTouched === void 0) {\n      isTouched = true;\n    }\n\n    var _ref8 = _temp5 === void 0 ? {} : _temp5,\n        _ref8$shouldValidate = _ref8.shouldValidate,\n        shouldValidate = _ref8$shouldValidate === void 0 ? validateOnBlur : _ref8$shouldValidate;\n\n    if (isTouched) {\n      setStateRef(\"touched.\" + name, true);\n    } else {\n      handleUnset(\"touched.\" + name);\n    }\n\n    if (shouldValidate) validateFieldWithLowPriority(name);\n  }, [handleUnset, setStateRef, validateFieldWithLowPriority, validateOnBlur]);\n  var setTouchedMaybeValidate = useCallback(function (name) {\n    return setTouched(name, true, {\n      shouldValidate: validateOnChange ? name !== changedFieldRef.current : undefined\n    });\n  }, [setTouched, validateOnChange]);\n  var setDirty = useCallback(function (name, isDirty) {\n    if (isDirty === void 0) {\n      isDirty = true;\n    }\n\n    if (isDirty) {\n      setStateRef(\"dirty.\" + name, true);\n    } else {\n      handleUnset(\"dirty.\" + name);\n    }\n  }, [handleUnset, setStateRef]);\n  var setDirtyIfNeeded = useCallback(function (name) {\n    return setDirty(name, !dequal(get(stateRef.current.values, name), get(initialStateRef.current.values, name)));\n  }, [setDirty, stateRef]);\n  var setValue = useCallback(function (name, value, _temp6) {\n    var _ref9 = _temp6 === void 0 ? {} : _temp6,\n        _ref9$shouldValidate = _ref9.shouldValidate,\n        shouldValidate = _ref9$shouldValidate === void 0 ? validateOnChange : _ref9$shouldValidate,\n        _ref9$shouldTouched = _ref9.shouldTouched,\n        shouldTouched = _ref9$shouldTouched === void 0 ? true : _ref9$shouldTouched,\n        _ref9$shouldDirty = _ref9.shouldDirty,\n        shouldDirty = _ref9$shouldDirty === void 0 ? true : _ref9$shouldDirty;\n\n    value = isFunction(value) ? value(get(stateRef.current.values, name)) : value;\n\n    if (!isUndefined(value)) {\n      setStateRef(\"values.\" + name, value);\n    } else {\n      handleUnset(\"values.\" + name);\n    }\n\n    setNodeValue(name, value);\n    isFieldArray(fieldArrayRef.current, name, function (key) {\n      return fieldArrayRef.current[key].reset();\n    });\n    if (shouldTouched) setTouched(name, true, {\n      shouldValidate: false\n    });\n    if (shouldDirty) setDirtyIfNeeded(name);\n    if (shouldValidate) validateFieldWithLowPriority(name);\n  }, [handleUnset, setDirtyIfNeeded, setNodeValue, setStateRef, setTouched, stateRef, validateFieldWithLowPriority, validateOnChange]);\n  var getOptions = useCallback(function () {\n    return {\n      getState: getState,\n      setValue: setValue,\n      setTouched: setTouched,\n      setDirty: setDirty,\n      setError: setError,\n      clearErrors: clearErrors,\n      runValidation: runValidation,\n      removeField: removeField,\n      focus: focus,\n      reset: reset,\n      submit: submit\n    };\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  var reset = useCallback(function (values, exclude, e) {\n    if (e != null && e.preventDefault) e.preventDefault();\n    if (e != null && e.stopPropagation) e.stopPropagation();\n\n    var state = _extends({}, stateRef.current);\n\n    var skip = arrayToMap(exclude || []);\n    Object.keys(state).forEach(function (key) {\n      if (skip[key]) return;\n\n      if (key === \"values\") {\n        var nextValues = (isFunction(values) ? values(stateRef.current.values) : values) || initialStateRef.current.values;\n        state[key] = nextValues;\n        initialStateRef.current.values = nextValues;\n        setNodesOrValues(nextValues, {\n          shouldSetValues: false,\n          fields: Array.from(fieldsRef.current.keys()).filter(function (name) {\n            return !isFieldArray(fieldArrayRef.current, name);\n          })\n        });\n      } else {\n        // @ts-expect-error\n        state[key] = initialStateRef.current[key];\n      }\n    });\n    setStateRef(\"\", state);\n    onResetRef.current(state.values, getOptions(), e);\n    Object.values(fieldArrayRef.current).forEach(function (field) {\n      return field.reset();\n    });\n  }, [getOptions, onResetRef, setNodesOrValues, setStateRef, stateRef]);\n  var submit = useCallback(async function (e) {\n    if (e != null && e.preventDefault) e.preventDefault();\n    if (e != null && e.stopPropagation) e.stopPropagation();\n    var nextTouched = [].concat(Array.from(fieldsRef.current.keys()), Object.keys(controlsRef.current)).reduce(function (touched, name) {\n      touched = set(touched, name, true, true);\n      return touched;\n    }, stateRef.current.touched);\n    setStateRef(\"touched\", nextTouched);\n    setStateRef(\"isSubmitted\", false);\n    setStateRef(\"isSubmitting\", true);\n\n    try {\n      var isValid = await runValidation();\n\n      if (!isValid) {\n        var errors = stateRef.current.errors;\n        onErrorRef.current(errors, getOptions(), e);\n\n        if (focusOnError) {\n          var names = Array.isArray(focusOnError) ? focusOnError : Array.from(fieldsRef.current.keys());\n          names = isFunction(focusOnError) ? focusOnError(names) : names;\n          var name = names.find(function (n) {\n            return get(errors, n);\n          });\n          if (name) handleFocus(name);\n        }\n\n        return {\n          errors: errors\n        };\n      }\n\n      await onSubmitRef.current(stateRef.current.values, getOptions(), e);\n      setStateRef(\"isSubmitted\", true);\n      return {\n        values: stateRef.current.values\n      };\n    } catch (exception) {\n      warn(\"\\uD83D\\uDCA1 react-cool-form > submit: \", exception);\n      throw exception;\n    } finally {\n      setStateRef(\"isSubmitting\", false);\n    }\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  [getOptions, handleFocus, onErrorRef, onSubmitRef, runValidation, setStateRef, stateRef]);\n  var handleChangeEvent = useCallback(function (name, value) {\n    setStateRef(\"values.\" + name, value);\n    setDirtyIfNeeded(name);\n    if (validateOnChange) validateFieldWithLowPriority(name);\n  }, [setDirtyIfNeeded, setStateRef, validateFieldWithLowPriority, validateOnChange]);\n  var shouldRemoveField = useCallback(function (name) {\n    if (!removeOnUnmounted) return false;\n    var names = Array.isArray(removeOnUnmounted) ? removeOnUnmounted : [].concat(Array.from(fieldsRef.current.keys()), Object.keys(controlsRef.current), Object.keys(fieldArrayRef.current));\n    names = isFunction(removeOnUnmounted) ? removeOnUnmounted(names) : names;\n    return names.includes(name);\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  var removeField = useCallback(function (name, exclude) {\n    var _arrayToMap = arrayToMap(exclude || [], {\n      value: \"values\",\n      error: \"errors\"\n    }),\n        defaultValue = _arrayToMap.defaultValue,\n        rest = _objectWithoutPropertiesLoose(_arrayToMap, _excluded$1);\n\n    if (!defaultValue) initialStateRef.current.values = unset(initialStateRef.current.values, name, true);\n    [\"values\", \"touched\", \"dirty\", \"errors\"].forEach(function (key, idx, arr) {\n      var shouldForceUpdate = idx === arr.length - 1;\n      if (!rest[key] && !isUndefined(get(stateRef.current[key], name))) handleUnset(key + \".\" + name, {\n        shouldSkipUpdate: !shouldForceUpdate,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    });\n    delete fieldParsersRef.current[name];\n    delete fieldValidatorsRef.current[name];\n    delete fieldArrayRef.current[name];\n    delete controlsRef.current[name];\n    if (fieldsRef.current.has(name)) fieldsRef.current[\"delete\"](name);\n  }, [handleUnset, stateRef]);\n  var registerForm = useCallback(function (el) {\n    if (!el) return;\n    formRef.current = el;\n    var form = formRef.current;\n    fieldsRef.current = getFields(form);\n    setNodesOrValues(initialStateRef.current.values);\n\n    handlersRef.current.change = function (_ref10) {\n      var target = _ref10.target;\n      var _ref11 = target,\n          name = _ref11.name;\n\n      if (fieldsRef.current.has(name) && !controlsRef.current[name]) {\n        var _fieldParsersRef$curr3;\n\n        var parse = (_fieldParsersRef$curr3 = fieldParsersRef.current[name]) == null ? void 0 : _fieldParsersRef$curr3.parse;\n        var value = getNodeValue(name);\n        handleChangeEvent(name, parse ? parse(value) : value);\n        changedFieldRef.current = name;\n      }\n    };\n\n    handlersRef.current.blur = function (_ref12) {\n      var target = _ref12.target;\n      if (!isFieldElement(target)) return;\n      var _ref13 = target,\n          name = _ref13.name;\n\n      if (fieldsRef.current.has(name) && !controlsRef.current[name]) {\n        setTouchedMaybeValidate(name);\n        changedFieldRef.current = undefined;\n      }\n    };\n\n    handlersRef.current.submit = function (e) {\n      return submit(e);\n    };\n\n    handlersRef.current.reset = function (e) {\n      return reset(null, null, e);\n    };\n\n    form.addEventListener(\"input\", handlersRef.current.change);\n    form.addEventListener(\"focusout\", handlersRef.current.blur);\n    form.addEventListener(\"submit\", handlersRef.current.submit);\n    form.addEventListener(\"reset\", handlersRef.current.reset);\n    mutationObserverRef.current = new MutationObserver(function (_ref14) {\n      var type = _ref14[0].type;\n      if (type !== \"childList\") return;\n      var fields = getFields(form);\n      var values = initialStateRef.current.values;\n      fieldsRef.current.forEach(function (_, name) {\n        var _fieldsRef$current$ge3, _fieldsRef$current$ge4, _fields$get$options;\n\n        if (!shouldRemoveField(name)) return;\n        if (controlsRef.current[name]) return;\n\n        if (!fields.has(name)) {\n          removeField(name, !isFieldArray(fieldArrayRef.current, name) || isUndefined(get(initialStateRef.current.values, name.split(\".\")[0])) ? undefined : [\"defaultValue\"]);\n          return;\n        }\n\n        var currOptions = (_fieldsRef$current$ge3 = fieldsRef.current.get(name)) == null ? void 0 : (_fieldsRef$current$ge4 = _fieldsRef$current$ge3.options) == null ? void 0 : _fieldsRef$current$ge4.length;\n        var nextOptions = (_fields$get$options = fields.get(name).options) == null ? void 0 : _fields$get$options.length;\n\n        if (currOptions > nextOptions) {\n          setStateRef(\"values.\" + name, getNodeValue(name, fields), {\n            shouldSkipUpdate: true\n          });\n        } else if (currOptions < nextOptions) {\n          setNodeValue(name, get(values, name), fields);\n        }\n      });\n      var addedNodes = [];\n      fields.forEach(function (_, name) {\n        if (fieldsRef.current.has(name) || controlsRef.current[name]) return;\n        var value = get(stateRef.current.values, name);\n        if (!isUndefined(value)) values = set(values, name, value, true);\n        addedNodes.push(name);\n      });\n      fieldsRef.current = fields;\n      if (addedNodes.length) setNodesOrValues(values, {\n        fields: addedNodes\n      });\n    });\n    mutationObserverRef.current.observe(form, {\n      childList: true,\n      subtree: true\n    });\n  }, [getFields, getNodeValue, handleChangeEvent, removeField, reset, setNodeValue, setNodesOrValues, setStateRef, setTouchedMaybeValidate, shouldRemoveField, stateRef, submit]);\n  var registerField = useCallback(function (value) {\n    return function (field) {\n      if (!(field != null && field.name) || controlsRef.current[field.name] || excludeFieldsRef.current[field.name]) return;\n\n      if (isFunction(value)) {\n        fieldValidatorsRef.current[field.name] = value;\n        return;\n      }\n\n      var validator = value.validate,\n          parsers = _objectWithoutPropertiesLoose(value, _excluded2$1);\n\n      if (validator) fieldValidatorsRef.current[field.name] = validator;\n      fieldParsersRef.current[field.name] = parsers;\n    };\n  }, []);\n  set$1(id, {\n    validateOnChange: validateOnChange,\n    shouldRemoveField: shouldRemoveField,\n    initialStateRef: initialStateRef,\n    fieldArrayRef: fieldArrayRef,\n    controlsRef: controlsRef,\n    observersRef: observersRef,\n    fieldValidatorsRef: fieldValidatorsRef,\n    changedFieldRef: changedFieldRef,\n    setStateRef: setStateRef,\n    getNodeValue: getNodeValue,\n    getFormState: getFormState,\n    setDefaultValue: setDefaultValue,\n    setNodesOrValues: setNodesOrValues,\n    setTouchedMaybeValidate: setTouchedMaybeValidate,\n    handleChangeEvent: handleChangeEvent,\n    removeField: removeField,\n    form: registerForm,\n    field: registerField,\n    focus: focus,\n    use: use,\n    getState: getState,\n    setValue: setValue,\n    setTouched: setTouched,\n    setDirty: setDirty,\n    setError: setError,\n    clearErrors: clearErrors,\n    runValidation: runValidation,\n    reset: reset,\n    submit: submit\n  });\n  useEffect(function () {\n    return function () {\n      if (formRef.current) {\n        var _mutationObserverRef$;\n\n        var handlers = handlersRef.current;\n        formRef.current.removeEventListener(\"input\", handlers.change);\n        formRef.current.removeEventListener(\"focusout\", handlers.blur);\n        formRef.current.removeEventListener(\"submit\", handlers.submit);\n        formRef.current.removeEventListener(\"reset\", handlers.reset);\n        (_mutationObserverRef$ = mutationObserverRef.current) == null ? void 0 : _mutationObserverRef$.disconnect();\n      }\n\n      remove(id);\n    };\n  }, [id]);\n  return {\n    form: registerForm,\n    field: registerField,\n    focus: focus,\n    removeField: removeField,\n    use: use,\n    getState: getState,\n    setValue: setValue,\n    setTouched: setTouched,\n    setDirty: setDirty,\n    setError: setError,\n    clearErrors: clearErrors,\n    runValidation: runValidation,\n    reset: reset,\n    submit: submit\n  };\n};\n\nvar useFormMethods = function (formId) {\n  var methods = get$1(formId);\n  invariant(!methods, 'ðŸ’¡ react-cool-form > useFormMethods: It must work with an \"useForm\" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form');\n  var form = methods.form,\n      field = methods.field,\n      focus = methods.focus,\n      removeField = methods.removeField,\n      use = methods.use,\n      getState = methods.getState,\n      setValue = methods.setValue,\n      setTouched = methods.setTouched,\n      setDirty = methods.setDirty,\n      setError = methods.setError,\n      clearErrors = methods.clearErrors,\n      runValidation = methods.runValidation,\n      reset = methods.reset,\n      submit = methods.submit;\n  return {\n    form: form,\n    field: field,\n    focus: focus,\n    removeField: removeField,\n    use: use,\n    getState: getState,\n    setValue: setValue,\n    setTouched: setTouched,\n    setDirty: setDirty,\n    setError: setError,\n    clearErrors: clearErrors,\n    runValidation: runValidation,\n    reset: reset,\n    submit: submit\n  };\n};\n\nvar useFormState = function (path, configOrCallback, formId) {\n  var config = !isFunction(configOrCallback) ? configOrCallback : {};\n  var methods = get$1((config == null ? void 0 : config.formId) || formId);\n  invariant(!methods, \"\\uD83D\\uDCA1 react-cool-form > useFormState: It must work with an \\\"useForm\\\" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form\");\n  var observerRef = useRef();\n\n  var _useReducer = useReducer(function (c) {\n    return c + 1;\n  }, 0),\n      forceUpdate = _useReducer[1];\n\n  var observersRef = methods.observersRef,\n      getFormState = methods.getFormState;\n\n  var _callback = isFunction(configOrCallback) ? configOrCallback : undefined;\n\n  useEffect(function () {\n    observersRef.current.push(observerRef.current);\n    return function () {\n      observersRef.current = observersRef.current.filter(function (o) {\n        return o !== observerRef.current;\n      });\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return getFormState(path, _extends({}, config, {\n    methodName: _callback ? \"useFormStateCallback\" : \"useFormState\",\n    callback: function callback(usedState) {\n      if (!observerRef.current) observerRef.current = {\n        usedState: usedState,\n        notify: _callback ? function (state) {\n          return _callback(parseState(path, state));\n        } : forceUpdate\n      };\n    }\n  }));\n};\n\nvar _excluded = [\"formId\", \"defaultValue\", \"validate\", \"parse\", \"format\", \"errorWithTouched\"],\n    _excluded2 = [\"onChange\", \"onBlur\"];\n\nvar useControlled = function (name, _temp) {\n  var _ref2;\n\n  var _ref = _temp === void 0 ? {} : _temp,\n      formId = _ref.formId,\n      defaultValue = _ref.defaultValue,\n      validate = _ref.validate,\n      parse = _ref.parse,\n      format = _ref.format,\n      errorWithTouched = _ref.errorWithTouched,\n      props = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  var methods = get$1(formId);\n  invariant(!methods, 'ðŸ’¡ react-cool-form > useControlled: It must work with an \"useForm\" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form');\n  var meta = useFormState({\n    value: \"values.\" + name,\n    error: \"errors.\" + name,\n    isTouched: \"touched.\" + name,\n    isDirty: \"dirty.\" + name\n  }, {\n    formId: formId,\n    errorWithTouched: errorWithTouched\n  });\n  var shouldRemoveField = methods.shouldRemoveField,\n      initialStateRef = methods.initialStateRef,\n      fieldArrayRef = methods.fieldArrayRef,\n      controlsRef = methods.controlsRef,\n      fieldValidatorsRef = methods.fieldValidatorsRef,\n      changedFieldRef = methods.changedFieldRef,\n      getState = methods.getState,\n      getNodeValue = methods.getNodeValue,\n      setDefaultValue = methods.setDefaultValue,\n      setTouchedMaybeValidate = methods.setTouchedMaybeValidate,\n      handleChangeEvent = methods.handleChangeEvent,\n      removeField = methods.removeField;\n  useEffect(function () {\n    var isFieldArr = isFieldArray(fieldArrayRef.current, name);\n    var initialVal = get(initialStateRef.current.values, name);\n\n    if (isUndefined(initialVal)) {\n      if (!isUndefined(defaultValue) && (!isFieldArr || !isUndefined(get(initialStateRef.current.values, name.split(\".\")[0])))) {\n        setDefaultValue(name, defaultValue);\n      } else if (!isFieldArr) {\n        warn(\"\\uD83D\\uDCA1 react-cool-form > useControlled: Please provide a default value for \\\"\" + name + \"\\\" field.\");\n      }\n    } else if (isUndefined(getState(name))) {\n      setDefaultValue(name, initialVal);\n    }\n\n    return function () {\n      if (shouldRemoveField(name)) removeField(name, !isFieldArr || isUndefined( // eslint-disable-next-line react-hooks/exhaustive-deps\n      get(initialStateRef.current.values, name.split(\".\")[0])) ? undefined : [\"defaultValue\"]);\n    };\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  controlsRef.current[name] = true;\n  if (validate) fieldValidatorsRef.current[name] = validate;\n\n  var _onChange = props.onChange,\n      _onBlur = props.onBlur,\n      restProps = _objectWithoutPropertiesLoose(props, _excluded2);\n\n  var value = get(initialStateRef.current.values, name);\n  value = !isUndefined(value) ? value : defaultValue;\n  value = !isUndefined(meta.value) ? meta.value : value;\n  value = (_ref2 = format ? format(value) : value) != null ? _ref2 : \"\";\n  return [_extends({\n    name: name,\n    value: value,\n    onChange: function onChange() {\n      var val;\n\n      if (parse) {\n        val = parse.apply(void 0, arguments);\n      } else {\n        var e = arguments.length <= 0 ? undefined : arguments[0];\n        val = (e == null ? void 0 : e.nativeEvent) instanceof Event && isFieldElement(e.target) ? getNodeValue(name) : e;\n      }\n\n      handleChangeEvent(name, val);\n      if (_onChange) _onChange.apply(void 0, arguments);\n      changedFieldRef.current = name;\n    },\n    onBlur: function onBlur(e) {\n      setTouchedMaybeValidate(name);\n      if (_onBlur) _onBlur(e);\n      changedFieldRef.current = undefined;\n    }\n  }, restProps), {\n    error: meta.error,\n    isTouched: !!meta.isTouched,\n    isDirty: !!meta.isDirty\n  }];\n};\n\nvar useFieldArray = function (name, _temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      formId = _ref.formId,\n      defaultValue = _ref.defaultValue,\n      validate = _ref.validate;\n\n  var methods = get$1(formId);\n  invariant(!methods, 'ðŸ’¡ react-cool-form > useFieldArray: It must work with an \"useForm\" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form');\n  var validateOnChange = methods.validateOnChange,\n      shouldRemoveField = methods.shouldRemoveField,\n      initialStateRef = methods.initialStateRef,\n      fieldArrayRef = methods.fieldArrayRef,\n      fieldValidatorsRef = methods.fieldValidatorsRef,\n      getState = methods.getState,\n      setDefaultValue = methods.setDefaultValue,\n      setNodesOrValues = methods.setNodesOrValues,\n      setStateRef = methods.setStateRef,\n      runValidation = methods.runValidation,\n      removeField = methods.removeField;\n  var getFields = useCallback(function (init) {\n    if (init === void 0) {\n      init = false;\n    }\n\n    var fields = getState(name);\n    if (init && isUndefined(fields)) fields = defaultValue;\n    return Array.isArray(fields) ? fields.map(function (_, index) {\n      return name + \"[\" + index + \"]\";\n    }) : [];\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  [getState, name]);\n\n  var _useState = useState$1(getFields(true)),\n      fields = _useState[0],\n      setFields = _useState[1];\n\n  var updateFields = useCallback(function () {\n    setFields(getFields());\n    setNodesOrValues(getState(\"values\"), {\n      shouldSetValues: false,\n      fields: Object.keys(fieldArrayRef.current[name].fields)\n    });\n  }, [fieldArrayRef, getFields, getState, name, setNodesOrValues]);\n  useEffect(function () {\n    if (isUndefined(get(initialStateRef.current.values, name)) && !isUndefined(defaultValue)) {\n      setDefaultValue(name, defaultValue, true);\n      updateFields();\n    }\n\n    return function () {\n      if (shouldRemoveField(name)) removeField(name);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  if (!fieldArrayRef.current[name]) fieldArrayRef.current[name] = {\n    reset: updateFields,\n    fields: {}\n  };\n  if (validate) fieldValidatorsRef.current[name] = validate;\n  var setState = useCallback(function (handler, _temp2) {\n    var _ref2 = _temp2 === void 0 ? {} : _temp2,\n        shouldTouched = _ref2.shouldTouched,\n        shouldDirty = _ref2.shouldDirty;\n\n    var state = getState();\n    [\"values\", \"touched\", \"errors\", \"dirty\"].forEach(function (key) {\n      var _state$values$name, _extends2;\n\n      var value = state[key][name];\n      var fieldsLength = (_state$values$name = state.values[name]) == null ? void 0 : _state$values$name.length;\n      if (key === \"values\" || key === \"touched\" && shouldTouched || key === \"dirty\" && shouldDirty || !isUndefined(value)) state = set(state, key, _extends({}, state[key], (_extends2 = {}, _extends2[name] = handler(Array.isArray(value) ? [].concat(value) : [], key, fieldsLength ? fieldsLength - 1 : 0), _extends2)), true);\n    });\n    setStateRef(\"\", _extends({}, state, {\n      shouldDirty: getIsDirty(state.dirty)\n    }));\n    updateFields();\n    if (validateOnChange) runValidation(name);\n  }, [getState, name, runValidation, setStateRef, updateFields, validateOnChange]);\n  var push = useCallback(function (value, _temp3) {\n    var _ref3 = _temp3 === void 0 ? {} : _temp3,\n        shouldTouched = _ref3.shouldTouched,\n        _ref3$shouldDirty = _ref3.shouldDirty,\n        shouldDirty = _ref3$shouldDirty === void 0 ? true : _ref3$shouldDirty;\n\n    var handler = function handler(f, type, lastIndex) {\n      if (lastIndex === void 0) {\n        lastIndex = 0;\n      }\n\n      if (type === \"values\") {\n        f.push(value);\n      } else if (type === \"touched\" && shouldTouched || type === \"dirty\" && shouldDirty) {\n        f[lastIndex] = setValuesAsTrue(value);\n      }\n\n      return f;\n    };\n\n    setState(handler, {\n      shouldTouched: shouldTouched,\n      shouldDirty: shouldDirty\n    });\n  }, [setState]);\n  var insert = useCallback(function (index, value, _temp4) {\n    var _ref4 = _temp4 === void 0 ? {} : _temp4,\n        shouldTouched = _ref4.shouldTouched,\n        _ref4$shouldDirty = _ref4.shouldDirty,\n        shouldDirty = _ref4$shouldDirty === void 0 ? true : _ref4$shouldDirty;\n\n    var handler = function handler(f, type) {\n      if (type === \"values\") {\n        f.splice(index, 0, value);\n      } else if (type === \"touched\" && shouldTouched || type === \"dirty\" && shouldDirty) {\n        f[index] = setValuesAsTrue(value);\n      } else if (index < f.length) {\n        f.splice(index, 0, undefined);\n      }\n\n      return f;\n    };\n\n    setState(handler, {\n      shouldTouched: shouldTouched,\n      shouldDirty: shouldDirty\n    });\n  }, [setState]);\n  var remove = useCallback(function (index) {\n    var handler = function handler(f) {\n      f.splice(index, 1);\n      return compact(f).length ? f : [];\n    };\n\n    var value = (getState(name) || [])[index];\n    setState(handler);\n    return value;\n  }, [getState, name, setState]);\n  var swap = useCallback(function (indexA, indexB) {\n    var handler = function handler(f) {\n      var _ref5 = [f[indexB], f[indexA]];\n      f[indexA] = _ref5[0];\n      f[indexB] = _ref5[1];\n      return f;\n    };\n\n    setState(handler);\n  }, [setState]);\n  var move = useCallback(function (from, to) {\n    var handler = function handler(f) {\n      f.splice(to, 0, f.splice(from, 1)[0]);\n      return f;\n    };\n\n    setState(handler);\n  }, [setState]);\n  return [fields, {\n    push: push,\n    insert: insert,\n    remove: remove,\n    swap: swap,\n    move: move\n  }];\n};\n\nexport { get, set, unset, useControlled, useFieldArray, useForm, useFormMethods, useFormState };","map":{"version":3,"sources":["../src/shared.ts","../src/hooks/useLatest.ts","../src/utils/arrayToMap.ts","../src/utils/isFileList.ts","../src/utils/isObject.ts","../src/utils/cloneObject.ts","../src/utils/compact.ts","../src/utils/isPlainObject.ts","../src/utils/deepMerge.ts","../src/utils/isUndefined.ts","../src/utils/filterErrors.ts","../src/utils/stringToPath.ts","../src/utils/get.ts","../src/utils/getIsDirty.ts","../src/utils/getPath.ts","../src/utils/invariant.ts","../src/utils/isFunction.ts","../src/utils/isAsyncFunction.ts","../src/utils/isCheckboxInput.ts","../src/utils/isEmptyObject.ts","../src/utils/isFieldArray.ts","../src/utils/isFieldElement.ts","../src/utils/isFileInput.ts","../src/utils/isInputElement.ts","../src/utils/isNumberInput.ts","../src/utils/isRadioInput.ts","../src/utils/isRangeInput.ts","../src/utils/isSelectMultiple.ts","../src/utils/isSelectOne.ts","../src/utils/parseState.ts","../src/utils/runWithLowPriority.ts","../src/utils/set.ts","../src/utils/setValuesAsTrue.ts","../src/utils/unset.ts","../src/utils/warn.ts","../src/hooks/useState.ts","../src/useForm.ts","../src/useFormMethods.ts","../src/useFormState.ts","../src/useControlled.ts","../src/useFieldArray.ts"],"names":["all","get","id","set","one","remove","ref","useRef","map","obj","value","cloneObject","object","isObject","isFileList","Array","arr","deepMerge","objects","Object","prevValue","prev","currValue","isPlainObject","filterErrors","touched","nextErrors","error","isUndefined","str","compact","search","found","val","path","__DEV__","isFunction","field","name","fieldName","callback","element","pathHandler","getPath","isGetState","parsedState","p","stateHandler","paths","s","window","start","Date","setTimeout","cb","didTimeout","timeRemaining","Math","timeout","newObject","immutable","segs","stringToPath","nextIsNumber","Number","idx","setValuesAsTrue","unset","refObject","last","target","index","isEmptyObject","forceUpdate","useReducer","c","stateRef","observersRef","usedState","notify","onChangeRef","useLatest","onChange","setStateRef","useCallback","fieldPath","shouldSkipUpdate","shouldForceUpdate","key","dequal","state","errors","dirty","prevIsDirty","prevIsValid","prevSubmitCount","currSubmitCount","isDirty","getIsDirty","isValid","submitCount","k","defaultValues","validate","validateOnChange","validateOnBlur","focusOnError","removeOnUnmounted","builtInValidationMode","excludeFields","onReset","onSubmit","onError","onStateChange","handlersRef","mutationObserverRef","formRef","fieldsRef","fieldParsersRef","fieldArrayRef","controlsRef","formValidatorRef","fieldValidatorsRef","changedFieldRef","excludeFieldsRef","arrayToMap","onResetRef","onSubmitRef","onErrorRef","hasWarnValues","initialStateRef","values","isValidating","isSubmitting","isSubmitted","useState","handleUnset","getFields","form","type","fieldId","classList","rcfExclude","exclude","warn","fieldArrayName","isFieldArray","acc","isCheckboxInput","isRadioInput","isSelectOne","isSelectMultiple","getNodeValue","fields","current","options","isInputElement","isNumberInput","isRangeInput","checkboxes","checkbox","radio","option","isFileInput","setNodeValue","setDefaultValue","shouldUpdateDefaultValue","setNodesOrValues","shouldSetValues","setError","clearErrors","runBuiltInValidation","validity","validationMessage","runAllBuiltInValidation","runFieldValidation","runAllFieldsValidation","promises","runFormValidation","validateField","hasAsyncValidator","isAsyncFunction","validateFieldWithLowPriority","runWithLowPriority","validateForm","errs","runValidation","getFormState","errorWithTouched","dfValues","methodName","parseState","v","handleFocus","n","focus","use","getState","setTouched","isTouched","shouldValidate","setTouchedMaybeValidate","undefined","setDirty","setDirtyIfNeeded","setValue","shouldTouched","shouldDirty","getOptions","removeField","reset","submit","e","skip","nextValues","nextTouched","names","handleChangeEvent","shouldRemoveField","defaultValue","rest","registerForm","parse","isFieldElement","currOptions","nextOptions","addedNodes","childList","subtree","registerField","validator","parsers","shared","useEffect","handlers","methods","invariant","config","observerRef","o","formId","format","props","meta","useFormState","isFieldArr","initialVal","onBlur","restProps","init","setFields","updateFields","setState","fieldsLength","handler","push","lastIndex","f","insert","swap","move"],"mappings":"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","sourcesContent":["import { Methods, ObjMap } from \"./types\";\n\nlet one: Methods | undefined;\nconst all: ObjMap<Methods> = {};\n\nexport const get = (id?: string): Methods => (id ? all[id] : (one as Methods));\n\nexport const set = (id: string | undefined, methods: Methods): void => {\n  if (id) {\n    all[id] = methods;\n  } else {\n    one = methods;\n  }\n};\n\nexport const remove = (id?: string): void => {\n  if (id) {\n    delete all[id];\n  } else {\n    one = undefined;\n  }\n};\n","import { MutableRefObject, useRef } from \"react\";\n\nexport default <T>(val: T): MutableRefObject<T> => {\n  const ref = useRef(val);\n  ref.current = val;\n  return ref;\n};\n","import { ObjMap } from \"../types\";\n\nexport default (arr: any[], map: Record<string, string> = {}): ObjMap =>\n  arr.reduce((obj, key) => {\n    obj[map[key] || key] = true;\n    return obj;\n  }, {});\n","export default (value: unknown): value is FileList => value instanceof FileList;\n","export default (value: unknown): value is Object =>\n  value !== null && typeof value === \"object\";\n","import isFileList from \"./isFileList\";\nimport isObject from \"./isObject\";\n\nconst cloneObject = (object: unknown): any => {\n  if (object instanceof Event) throw new Error(\"Unable to clone event.\");\n\n  if (!isObject(object) || isFileList(object)) return object;\n\n  if (object instanceof Date) return new Date(object.getTime());\n\n  if (Array.isArray(object)) return object.map((val) => cloneObject(val));\n\n  return Object.keys(object).reduce((obj: Record<string, any>, key) => {\n    obj[key] = cloneObject((object as Record<string, any>)[key]);\n    return obj;\n  }, {});\n};\n\nexport default cloneObject;\n","export default (arr: any[]): any[] => arr.filter(Boolean);\n","import isObject from \"./isObject\";\n\nexport default (value: unknown): value is Object =>\n  !Array.isArray(value) && !(value instanceof Date) && isObject(value);\n","import isPlainObject from \"./isPlainObject\";\n\nconst deepMerge = (...objects: any[]): any =>\n  objects.reduce((prev, obj) => {\n    Object.keys(obj).forEach((key) => {\n      const prevValue = prev[key];\n      const currValue = obj[key];\n\n      if (Array.isArray(prevValue) && Array.isArray(currValue)) {\n        prev[key] = [...prevValue, ...currValue];\n      } else if (isPlainObject(prevValue) && isPlainObject(currValue)) {\n        prev[key] = deepMerge(prevValue, currValue);\n      } else {\n        prev[key] = currValue;\n      }\n    });\n\n    return prev;\n  }, {});\n\nexport default deepMerge;\n","export default (value: unknown): value is undefined => value === undefined;\n","import { ObjMap } from \"../types\";\nimport isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\n\nconst filterErrors = (error: unknown, touched: unknown): any => {\n  if (!isPlainObject(error)) return touched ? error : undefined;\n\n  return Object.keys(error).reduce((obj: ObjMap<any>, key) => {\n    const nextErrors = filterErrors(\n      (error as ObjMap<any>)[key],\n      (touched as ObjMap<any>)[key] || false\n    );\n\n    if (!isUndefined(nextErrors)) {\n      obj[key] = nextErrors;\n    } else {\n      delete obj[key];\n    }\n\n    return obj;\n  }, {});\n};\n\nexport default filterErrors;\n","import compact from \"./compact\";\n\nexport default (str: string): string[] => {\n  if (typeof str !== \"string\") throw new TypeError(\"Expected a string.\");\n  if (!str.length) return [];\n\n  return compact(str.split(/[.[\\]]+/));\n};\n","import isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\nimport stringToPath from \"./stringToPath\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport default (object: any, path: string, defaultValue?: unknown): any => {\n  if (!isPlainObject(object) || !path) return defaultValue;\n\n  const value = stringToPath(path).reduce(\n    (obj, key) => (obj || {})[key],\n    object\n  );\n\n  return !isUndefined(value) ? value : defaultValue;\n};\n","import isObject from \"./isObject\";\n\nexport default (dirty: object): boolean => {\n  const search = (dty: object, found: any[] = []) => {\n    for (const val of Object.values(dty)) {\n      if (val === true) {\n        found.push(val);\n        return found;\n      }\n\n      if (isObject(val)) search(val, found);\n    }\n\n    return found;\n  };\n\n  return !!search(dirty).length;\n};\n","export default (path: string): string =>\n  ![\n    \"values\",\n    \"touched\",\n    \"errors\",\n    \"isDirty\",\n    \"dirty\",\n    \"isValidating\",\n    \"isValid\",\n    \"isSubmitting\",\n    \"isSubmitted\",\n    \"submitCount\",\n  ].some((key) => path.startsWith(key))\n    ? `values.${path}`\n    : path;\n","export default (condition: boolean, message: string): void => {\n  if (__DEV__ && condition) throw new Error(message);\n};\n","export default (value: unknown): value is Function =>\n  typeof value === \"function\";\n","import isFunction from \"./isFunction\";\n\nexport default (value: unknown): value is Promise<any> =>\n  isFunction(value) && value.constructor.name === \"AsyncFunction\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"checkbox\";\n","import { ObjMap } from \"../types\";\nimport isPlainObject from \"./isPlainObject\";\n\nexport default (value: unknown): value is ObjMap<never> =>\n  isPlainObject(value) && !Object.keys(value).length;\n","import { FieldArray } from \"../types\";\n\nexport default (\n  fields: FieldArray,\n  name: string,\n  callback?: (key: string) => void\n): string | void => {\n  let fieldName;\n\n  Object.keys(fields).some((key) => {\n    if (name.startsWith(key)) {\n      fieldName = key;\n      if (callback) callback(key);\n      return true;\n    }\n    return false;\n  });\n\n  return fieldName;\n};\n","import { FieldElement } from \"../types\";\n\nexport default (element: HTMLElement): element is FieldElement =>\n  /INPUT|TEXTAREA|SELECT/.test(element.tagName);\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"file\";\n","export default (element: HTMLElement): element is HTMLInputElement =>\n  element.tagName === \"INPUT\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"number\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"radio\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"range\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLSelectElement =>\n  field.type === \"select-multiple\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLSelectElement =>\n  field.type === \"select-one\";\n","import { FormState, ObjMap, Path } from \"../types\";\nimport get from \"./get\";\nimport getPath from \"./getPath\";\nimport isPlainObject from \"./isPlainObject\";\n\nexport default (\n  path: Path | undefined,\n  state: FormState,\n  pathHandler = getPath,\n  stateHandler?: (path: string, state: any) => any,\n  isGetState?: boolean\n): any => {\n  if (!path) return isGetState ? state : undefined;\n\n  let parsedState;\n\n  if (Array.isArray(path)) {\n    parsedState = path.map((p) => {\n      p = pathHandler(p);\n      const value = get(state, p);\n      return stateHandler ? stateHandler(p, value) : value;\n    });\n  } else if (isPlainObject(path)) {\n    const paths = path as ObjMap<string>;\n    parsedState = Object.keys(paths).reduce((s: ObjMap<any>, key) => {\n      path = pathHandler(paths[key]);\n      const value = get(state, path);\n      s[key] = stateHandler ? stateHandler(path, value) : value;\n      return s;\n    }, {});\n  } else {\n    path = pathHandler(path);\n    const value = get(state, path);\n    parsedState = stateHandler ? stateHandler(path, value) : value;\n  }\n\n  return parsedState;\n};\n","export default (callback: (args: any) => any): any =>\n  (\n    window.requestIdleCallback ||\n    ((cb) => {\n      const start = Date.now();\n      return setTimeout(\n        () =>\n          cb({\n            didTimeout: false,\n            timeRemaining: /* istanbul ignore next */ () =>\n              Math.max(0, 50 - (Date.now() - start)),\n          }),\n        1\n      );\n    })\n  )(callback, { timeout: 2000 });\n","import cloneObject from \"./cloneObject\";\nimport isPlainObject from \"./isPlainObject\";\nimport stringToPath from \"./stringToPath\";\n\nexport default (\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  object: any,\n  path: string,\n  value: unknown,\n  immutable?: boolean\n): any => {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n\n  const newObject = immutable ? cloneObject(object) : object;\n  const segs = stringToPath(path);\n\n  segs.slice(0, -1).reduce((obj, key, idx) => {\n    const nextIsNumber = !Number.isNaN(+segs[idx + 1]);\n    if (\n      (isPlainObject(obj[key]) && !nextIsNumber) ||\n      (Array.isArray(obj[key]) && nextIsNumber)\n    )\n      return obj[key];\n    obj[key] = nextIsNumber ? [] : {};\n    return obj[key];\n  }, newObject)[segs[segs.length - 1] || \"\"] = value;\n\n  return newObject;\n};\n","import isPlainObject from \"./isPlainObject\";\n\nconst setValuesAsTrue = (object: unknown): any => {\n  if (!Array.isArray(object) && !isPlainObject(object)) return true;\n\n  if (Array.isArray(object)) return object.map((val) => setValuesAsTrue(val));\n\n  return Object.keys(object).reduce((obj: Record<string, any>, key) => {\n    obj[key] = setValuesAsTrue((object as Record<string, any>)[key]);\n    return obj;\n  }, {});\n};\n\nexport default setValuesAsTrue;\n","import cloneObject from \"./cloneObject\";\nimport isEmptyObject from \"./isEmptyObject\";\nimport isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\nimport stringToPath from \"./stringToPath\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nconst unset = (object: any, path: string, immutable?: boolean): any => {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n\n  const refObject = immutable ? cloneObject(object) : object;\n  const newObject = refObject;\n\n  // eslint-disable-next-line no-prototype-builtins\n  if (newObject.hasOwnProperty(path)) {\n    delete newObject[path];\n    return refObject;\n  }\n\n  const segs = stringToPath(path);\n\n  if (!segs.length) return refObject;\n\n  const last = segs.pop() as string;\n  const target = segs.reduce((obj, key) => (obj || {})[key], newObject);\n\n  if (Array.isArray(target)) {\n    let index = +last;\n\n    if (index < target.length - 1) {\n      delete target[index];\n    } else {\n      while (index >= 0) {\n        // @ts-expect-error\n        if (index == last || isUndefined(target[index])) {\n          target.splice(index, 1);\n          index -= 1;\n        } else {\n          break;\n        }\n      }\n    }\n  } else if (isPlainObject(target)) {\n    delete target[last];\n  }\n\n  return isEmptyObject(target) ||\n    (Array.isArray(target) && !target.filter((t) => !isUndefined(t)).length)\n    ? unset(refObject, segs.join(\".\"))\n    : refObject;\n};\n\nexport default unset;\n","export default (...args: any[]): void => {\n  if (__DEV__) console.warn(...args);\n};\n","import { useReducer, useRef, useCallback } from \"react\";\nimport { dequal } from \"dequal/lite\";\n\nimport {\n  FormState,\n  FormStateReturn,\n  Observer,\n  OnStateChange,\n  SetStateRef,\n} from \"../types\";\nimport useLatest from \"./useLatest\";\nimport { get, getIsDirty, isEmptyObject, set } from \"../utils\";\n\nexport default <V>(\n  initialState: FormState<V>,\n  onChange?: OnStateChange<V>\n): FormStateReturn<V> => {\n  const [, forceUpdate] = useReducer((c) => c + 1, 0);\n  const stateRef = useRef(initialState);\n  const observersRef = useRef<Observer<V>[]>([\n    { usedState: {}, notify: forceUpdate },\n  ]);\n  const onChangeRef = useLatest(onChange || (() => undefined));\n\n  const setStateRef = useCallback<SetStateRef>(\n    (path, value, { fieldPath, shouldSkipUpdate, shouldForceUpdate } = {}) => {\n      const key = path.split(\".\")[0];\n\n      if (!key) {\n        if (!dequal(stateRef.current, value)) {\n          stateRef.current = value;\n          onChangeRef.current(stateRef.current);\n\n          observersRef.current.forEach(\n            ({ usedState, notify }) =>\n              !isEmptyObject(usedState) && notify(stateRef.current)\n          );\n        }\n\n        return;\n      }\n\n      if (\n        (path !== \"values\" && key === \"values\") ||\n        !dequal(get(stateRef.current, path), value)\n      ) {\n        const state = set(stateRef.current, path, value, true);\n        const {\n          errors,\n          dirty,\n          isDirty: prevIsDirty,\n          isValid: prevIsValid,\n          submitCount: prevSubmitCount,\n        } = state;\n        let { submitCount: currSubmitCount } = state;\n        const isDirty = key === \"dirty\" ? getIsDirty(dirty) : prevIsDirty;\n        const isValid = key === \"errors\" ? isEmptyObject(errors) : prevIsValid;\n        const submitCount =\n          key === \"isSubmitting\" && value\n            ? (currSubmitCount += 1)\n            : currSubmitCount;\n\n        stateRef.current = { ...state, isDirty, isValid, submitCount };\n        onChangeRef.current(stateRef.current);\n\n        if (shouldSkipUpdate) return;\n\n        path = fieldPath || path;\n        observersRef.current.forEach(\n          ({ usedState, notify }) =>\n            (shouldForceUpdate ||\n              Object.keys(usedState).some(\n                (k) => path.startsWith(k) || k.startsWith(path)\n              ) ||\n              (usedState.isDirty && isDirty !== prevIsDirty) ||\n              (usedState.isValid && isValid !== prevIsValid) ||\n              (usedState.submitCount && submitCount !== prevSubmitCount)) &&\n            notify(stateRef.current)\n        );\n      }\n    },\n    [onChangeRef]\n  );\n\n  return { stateRef, setStateRef, observersRef };\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n\nimport { useCallback, useEffect, useRef } from \"react\";\nimport { dequal } from \"dequal/lite\";\n\nimport * as shared from \"./shared\";\nimport {\n  ClearErrors,\n  FieldArray,\n  FieldElement,\n  Fields,\n  FieldValidator,\n  Focus,\n  FormConfig,\n  FormErrors,\n  FormMethods,\n  FormState,\n  FormValues,\n  GetFormState,\n  GetNodeValue,\n  GetState,\n  HandleChangeEvent,\n  Handlers,\n  ObjMap,\n  Parsers,\n  RegisterField,\n  RegisterForm,\n  RemoveField,\n  Reset,\n  RunValidation,\n  SetDefaultValue,\n  SetDirty,\n  SetError,\n  SetNodesOrValues,\n  SetTouched,\n  SetTouchedMaybeValidate,\n  SetValue,\n  ShouldRemoveField,\n  Submit,\n  Use,\n} from \"./types\";\nimport { useLatest, useState } from \"./hooks\";\nimport {\n  arrayToMap,\n  compact,\n  deepMerge,\n  filterErrors,\n  get,\n  getPath,\n  isAsyncFunction,\n  isCheckboxInput,\n  isEmptyObject,\n  isFieldArray,\n  isFieldElement,\n  isFileInput,\n  isFileList,\n  isFunction,\n  isInputElement,\n  isNumberInput,\n  isPlainObject,\n  isRadioInput,\n  isRangeInput,\n  isSelectMultiple,\n  isSelectOne,\n  isUndefined,\n  parseState,\n  runWithLowPriority,\n  set,\n  unset,\n  warn,\n} from \"./utils\";\n\nexport default <V extends FormValues = FormValues>({\n  id,\n  defaultValues = {} as V,\n  validate,\n  validateOnChange = true,\n  validateOnBlur = true,\n  focusOnError = true,\n  removeOnUnmounted = true,\n  builtInValidationMode = \"message\",\n  excludeFields = [],\n  onReset,\n  onSubmit,\n  onError,\n  onStateChange,\n}: FormConfig<V> = {}): FormMethods<V> => {\n  const handlersRef = useRef<Handlers>({});\n  const mutationObserverRef = useRef<MutationObserver>();\n  const formRef = useRef<HTMLElement>();\n  const fieldsRef = useRef<Fields>(new Map());\n  const fieldParsersRef = useRef<Parsers>({});\n  const fieldArrayRef = useRef<FieldArray>({});\n  const controlsRef = useRef<ObjMap>({});\n  const formValidatorRef = useLatest(validate);\n  const fieldValidatorsRef = useRef<ObjMap<FieldValidator<V>>>({});\n  const changedFieldRef = useRef<string>();\n  const excludeFieldsRef = useRef<ObjMap>(arrayToMap(excludeFields));\n  const onResetRef = useLatest(onReset || (() => undefined));\n  const onSubmitRef = useLatest(onSubmit || (() => undefined));\n  const onErrorRef = useLatest(onError || (() => undefined));\n  const hasWarnValues = useRef(false);\n  const initialStateRef = useRef<FormState<V>>({\n    values: defaultValues,\n    touched: {},\n    errors: {},\n    isDirty: false,\n    dirty: {},\n    isValidating: false,\n    isValid: true,\n    isSubmitting: false,\n    isSubmitted: false,\n    submitCount: 0,\n  });\n  const { stateRef, setStateRef, observersRef } = useState<V>(\n    initialStateRef.current,\n    onStateChange\n  );\n\n  const handleUnset = useCallback(\n    (\n      path: string,\n      options?: { shouldSkipUpdate?: boolean; shouldForceUpdate?: boolean }\n    ) => {\n      const segs = path.split(\".\");\n      const k = segs.shift() as string;\n      setStateRef(\n        k,\n        unset(stateRef.current[k as keyof FormState<V>], segs.join(\".\"), true),\n        { fieldPath: path, ...options }\n      );\n    },\n    [setStateRef, stateRef]\n  );\n\n  const getFields = useCallback(\n    (form: HTMLElement) =>\n      Array.from(form.querySelectorAll(\"input,textarea,select\"))\n        .filter((element) => {\n          const field = element as FieldElement;\n          const {\n            type,\n            name,\n            id: fieldId,\n            classList,\n            dataset: { rcfExclude },\n          } = field;\n          const { current: exclude } = excludeFieldsRef;\n\n          if (\n            /button|image|submit|reset/.test(type) ||\n            (fieldId && exclude[`#${fieldId}`]) ||\n            Array.from(classList).find((n) => exclude[`.${n}`])\n          )\n            return false;\n\n          if (rcfExclude !== \"true\" && !name) {\n            warn(\n              'ðŸ’¡ react-cool-form > field: Missing \"name\" attribute. Do you want to exclude the field? See: https://react-cool-form.netlify.app/docs/api-reference/use-form/#excludefields'\n            );\n            return false;\n          }\n\n          return (\n            controlsRef.current[name] ||\n            (rcfExclude !== \"true\" && !exclude[name])\n          );\n        })\n        .reduce((acc, elm) => {\n          const field = elm as FieldElement;\n          const { name } = field;\n          const fieldArrayName = isFieldArray(fieldArrayRef.current, name);\n\n          if (fieldArrayName)\n            fieldArrayRef.current[fieldArrayName].fields[name] = true;\n\n          acc.set(name, {\n            ...acc.get(name),\n            field: acc.get(name)?.field || field,\n          });\n\n          if (isCheckboxInput(field) || isRadioInput(field)) {\n            acc.get(name).options = acc.get(name).options\n              ? [...acc.get(name).options, field]\n              : [field];\n          } else if (isSelectOne(field) || isSelectMultiple(field)) {\n            acc.get(name).options = Array.from(field.options);\n          }\n\n          return acc;\n        }, new Map()),\n    []\n  );\n\n  const getNodeValue = useCallback<GetNodeValue>(\n    (name, fields = fieldsRef.current) => {\n      if (!fields.has(name)) return undefined;\n\n      const { field, options } = fields.get(name)!;\n\n      if (isInputElement(field)) {\n        if (fieldParsersRef.current[name]?.valueAsNumber)\n          return field.valueAsNumber;\n        if (fieldParsersRef.current[name]?.valueAsDate)\n          return field.valueAsDate;\n      }\n\n      if (isNumberInput(field) || isRangeInput(field))\n        return field.valueAsNumber || \"\";\n\n      if (isCheckboxInput(field)) {\n        const checkboxes = options as HTMLInputElement[];\n\n        if (checkboxes.length > 1)\n          return checkboxes.filter((c) => c.checked).map((c) => c.value);\n\n        const checkbox = checkboxes[0];\n\n        if (checkbox.hasAttribute(\"value\") && checkbox.value)\n          return checkbox.checked ? [checkbox.value] : [];\n\n        return checkbox.checked;\n      }\n\n      if (isRadioInput(field))\n        return (\n          (options as HTMLInputElement[]).find((radio) => radio.checked)\n            ?.value || \"\"\n        );\n\n      if (isSelectMultiple(field))\n        return (options as HTMLOptionElement[])\n          .filter((option) => option.selected)\n          .map((option) => option.value);\n\n      if (isFileInput(field)) return field.files;\n\n      return field.value;\n    },\n    []\n  );\n\n  const setNodeValue = useCallback(\n    (name: string, value: any, fields: Fields = fieldsRef.current) => {\n      if (!fields.has(name) || controlsRef.current[name]) return;\n\n      const { field, options } = fields.get(name)!;\n\n      if (isCheckboxInput(field)) {\n        const checkboxes = options as HTMLInputElement[];\n\n        if (checkboxes.length > 1) {\n          checkboxes.forEach((checkbox) => {\n            checkbox.checked = Array.isArray(value)\n              ? value.includes(checkbox.value)\n              : !!value;\n          });\n        } else {\n          checkboxes[0].checked = !!value;\n        }\n      } else if (isRadioInput(field)) {\n        (options as HTMLInputElement[]).forEach((radio) => {\n          radio.checked = radio.value === value;\n        });\n      } else if (isSelectMultiple(field) && Array.isArray(value)) {\n        (options as HTMLOptionElement[]).forEach((option) => {\n          option.selected = !!value.includes(option.value);\n        });\n      } else if (isFileInput(field)) {\n        if (isFileList(value)) field.files = value;\n        if (!value) field.value = \"\";\n      } else {\n        field.value = value ?? \"\";\n      }\n    },\n    []\n  );\n\n  const setDefaultValue = useCallback<SetDefaultValue>(\n    (\n      name,\n      value,\n      shouldUpdateDefaultValue = !isFieldArray(fieldArrayRef.current, name) ||\n        !isUndefined(get(initialStateRef.current.values, name.split(\".\")[0]))\n    ) => {\n      if (shouldUpdateDefaultValue)\n        initialStateRef.current.values = set(\n          initialStateRef.current.values,\n          name,\n          value,\n          true\n        );\n\n      if (!dequal(get(stateRef.current.values, name), value))\n        setStateRef(`values.${name}`, value, { shouldSkipUpdate: true });\n    },\n    [setStateRef, stateRef]\n  );\n\n  const setNodesOrValues = useCallback<SetNodesOrValues<V>>(\n    (\n      values,\n      {\n        shouldSetValues = true,\n        fields = Array.from(fieldsRef.current.keys()),\n      } = {}\n    ) =>\n      fields.forEach((name) => {\n        if (controlsRef.current[name]) return;\n\n        const value = get(values, name);\n\n        if (!isUndefined(value)) setNodeValue(name, value);\n\n        if (shouldSetValues)\n          setDefaultValue(\n            name,\n            !isUndefined(value) ? value : getNodeValue(name)\n          );\n      }),\n    [getNodeValue, setDefaultValue, setNodeValue]\n  );\n\n  const setError = useCallback<SetError>(\n    (name, error) => {\n      error = isFunction(error)\n        ? error(get(stateRef.current.errors, name))\n        : error;\n\n      if (error) {\n        setStateRef(`errors.${name}`, error);\n      } else {\n        handleUnset(`errors.${name}`);\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const clearErrors = useCallback<ClearErrors>(\n    (name) => {\n      if (!name) {\n        setStateRef(\"errors\", {});\n      } else if (Array.isArray(name)) {\n        name.forEach((n) => setError(n));\n      } else {\n        setError(name);\n      }\n    },\n    [setError, setStateRef]\n  );\n\n  const runBuiltInValidation = useCallback(\n    (name: string) => {\n      if (builtInValidationMode === false || !fieldsRef.current.has(name))\n        return undefined;\n\n      const {\n        field: { validity, validationMessage },\n      } = fieldsRef.current.get(name)!;\n\n      if (builtInValidationMode === \"state\")\n        for (const k in validity)\n          if (k !== \"valid\" && validity[k as keyof ValidityState]) return k;\n\n      return validationMessage;\n    },\n    [builtInValidationMode]\n  );\n\n  const runAllBuiltInValidation = useCallback(() => {\n    if (builtInValidationMode === false) return {};\n\n    return Array.from(fieldsRef.current.keys()).reduce((errors, name) => {\n      const error = runBuiltInValidation(name);\n      errors = { ...errors, ...(error ? set(errors, name, error) : {}) };\n      return errors;\n    }, {});\n  }, [builtInValidationMode, runBuiltInValidation]);\n\n  const runFieldValidation = useCallback(\n    async (name: string): Promise<any> => {\n      const value = get(stateRef.current.values, name);\n\n      if (!fieldValidatorsRef.current[name] || isUndefined(value))\n        return undefined;\n\n      try {\n        const error = await fieldValidatorsRef.current[name](\n          value,\n          stateRef.current.values\n        );\n\n        return error;\n      } catch (exception) {\n        warn(`ðŸ’¡ react-cool-form > validate ${name}: `, exception);\n        throw exception;\n      }\n    },\n    [stateRef]\n  );\n\n  const runAllFieldsValidation = useCallback((): Promise<FormErrors<V>> => {\n    const promises = Object.keys(fieldValidatorsRef.current).map((name) =>\n      runFieldValidation(name)\n    );\n\n    return Promise.all(promises).then((errors) =>\n      Object.keys(fieldValidatorsRef.current).reduce((acc, cur, idx) => {\n        acc = { ...acc, ...(errors[idx] ? set(acc, cur, errors[idx]) : {}) };\n        return acc;\n      }, {})\n    );\n  }, [runFieldValidation]);\n\n  const runFormValidation = useCallback(\n    async (name?: string): Promise<any> => {\n      if (!formValidatorRef.current) return name ? undefined : {};\n\n      try {\n        const errors = await formValidatorRef.current(stateRef.current.values);\n\n        if (name) return get(errors, name);\n\n        return isPlainObject(errors) ? errors : {};\n      } catch (exception) {\n        warn(`ðŸ’¡ react-cool-form > validate form: `, exception);\n        throw exception;\n      }\n    },\n    [formValidatorRef, stateRef]\n  );\n\n  const validateField = useCallback(\n    async (name: string) => {\n      const hasAsyncValidator =\n        isAsyncFunction(formValidatorRef.current) ||\n        isAsyncFunction(fieldValidatorsRef.current[name]);\n\n      if (hasAsyncValidator) setStateRef(\"isValidating\", true);\n\n      try {\n        const error =\n          (await runFormValidation(name)) ||\n          (await runFieldValidation(name)) ||\n          runBuiltInValidation(name);\n\n        setError(name, error);\n        if (hasAsyncValidator) setStateRef(\"isValidating\", false);\n\n        return error;\n      } catch (exception) {\n        return exception;\n      }\n    },\n    [\n      formValidatorRef,\n      runBuiltInValidation,\n      runFieldValidation,\n      runFormValidation,\n      setError,\n      setStateRef,\n    ]\n  );\n\n  const validateFieldWithLowPriority = useCallback<typeof validateField>(\n    (name) => runWithLowPriority(() => validateField(name)),\n    [validateField]\n  );\n\n  const validateForm = useCallback((): Promise<FormErrors<V>> => {\n    setStateRef(\"isValidating\", true);\n\n    return Promise.all([\n      runAllBuiltInValidation(),\n      runAllFieldsValidation(),\n      runFormValidation(),\n    ]).then((errors) => {\n      const errs = deepMerge(...errors);\n\n      setStateRef(\"errors\", errs);\n      setStateRef(\"isValidating\", false);\n\n      return errs;\n    });\n  }, [\n    runAllBuiltInValidation,\n    runAllFieldsValidation,\n    runFormValidation,\n    setStateRef,\n  ]);\n\n  const runValidation = useCallback<RunValidation>(\n    (name) => {\n      if (!name) return validateForm().then((errors) => isEmptyObject(errors));\n\n      if (Array.isArray(name))\n        return Promise.all(name.map((n) => validateField(n))).then(\n          (errors) => !compact(errors).length\n        );\n\n      return validateField(name).then((error) => !error);\n    },\n    [validateField, validateForm]\n  );\n\n  const getFormState = useCallback<GetFormState<V>>(\n    (\n      path,\n      {\n        errorWithTouched,\n        defaultValues: dfValues = {},\n        methodName = \"getState\",\n        callback,\n      } = {}\n    ) => {\n      const usedState: ObjMap = {};\n      const state = parseState(\n        path,\n        stateRef.current,\n        (p) => {\n          p = getPath(p);\n\n          if (methodName !== \"getState\") {\n            if (\n              p === \"values\" &&\n              methodName !== \"useFormStateCallback\" &&\n              !hasWarnValues.current\n            ) {\n              warn(\n                `ðŸ’¡ react-cool-form > ${methodName}: Getting \"values\" alone might cause unnecessary re-renders. If you know what you're doing, just ignore this warning. See: https://react-cool-form.netlify.app/docs/getting-started/form-state#best-practices`\n              );\n              hasWarnValues.current = true;\n            }\n\n            usedState[p] = true;\n          }\n\n          return p;\n        },\n        (p, v) => {\n          if (methodName === \"getState\") return v;\n\n          if (p.startsWith(\"values\")) {\n            if (!isUndefined(v)) return v;\n\n            p = p.replace(\"values.\", \"\");\n            v = get(initialStateRef.current, p);\n\n            return !isUndefined(v) ? v : get(dfValues, p);\n          }\n\n          if (!errorWithTouched || !p.startsWith(\"errors\")) return v;\n\n          p = p.replace(\"errors\", \"touched\");\n          usedState[p] = true;\n\n          return filterErrors(v, get(stateRef.current, p));\n        },\n        methodName === \"getState\"\n      );\n\n      if (callback) callback(usedState);\n\n      return state;\n    },\n    [stateRef]\n  );\n\n  const handleFocus = useCallback((name: string) => {\n    const field =\n      fieldsRef.current.get(name)?.field ||\n      fieldsRef.current.get(\n        Array.from(fieldsRef.current.keys()).find((n) => n.startsWith(name)) ||\n          \"\"\n      )?.field;\n\n    if (field && isFunction(field.focus)) field.focus();\n  }, []);\n\n  const focus = useCallback<Focus>(\n    (name, delay) => {\n      if (!isUndefined(delay)) {\n        setTimeout(() => handleFocus(name), delay);\n      } else {\n        handleFocus(name);\n      }\n    },\n    [handleFocus]\n  );\n\n  const use = useCallback<Use<V>>(\n    (path, { errorWithTouched, defaultValues: dfValues } = {}) =>\n      getFormState(path, {\n        errorWithTouched,\n        defaultValues: dfValues,\n        methodName: \"use\",\n        callback: (usedState) => {\n          observersRef.current[0].usedState = {\n            ...observersRef.current[0].usedState,\n            ...usedState,\n          };\n        },\n      }),\n    [getFormState, observersRef]\n  );\n\n  const getState = useCallback<GetState>(\n    (path) => getFormState(path),\n    [getFormState]\n  );\n\n  const setTouched = useCallback<SetTouched>(\n    (name, isTouched = true, { shouldValidate = validateOnBlur } = {}) => {\n      if (isTouched) {\n        setStateRef(`touched.${name}`, true);\n      } else {\n        handleUnset(`touched.${name}`);\n      }\n\n      if (shouldValidate) validateFieldWithLowPriority(name);\n    },\n    [handleUnset, setStateRef, validateFieldWithLowPriority, validateOnBlur]\n  );\n\n  const setTouchedMaybeValidate = useCallback<SetTouchedMaybeValidate>(\n    (name) =>\n      setTouched(name, true, {\n        shouldValidate: validateOnChange\n          ? name !== changedFieldRef.current\n          : undefined,\n      }),\n    [setTouched, validateOnChange]\n  );\n\n  const setDirty = useCallback<SetDirty>(\n    (name, isDirty = true) => {\n      if (isDirty) {\n        setStateRef(`dirty.${name}`, true);\n      } else {\n        handleUnset(`dirty.${name}`);\n      }\n    },\n    [handleUnset, setStateRef]\n  );\n\n  const setDirtyIfNeeded = useCallback(\n    (name: string) =>\n      setDirty(\n        name,\n        !dequal(\n          get(stateRef.current.values, name),\n          get(initialStateRef.current.values, name)\n        )\n      ),\n    [setDirty, stateRef]\n  );\n\n  const setValue = useCallback<SetValue>(\n    (\n      name,\n      value,\n      {\n        shouldValidate = validateOnChange,\n        shouldTouched = true,\n        shouldDirty = true,\n      } = {}\n    ) => {\n      value = isFunction(value)\n        ? value(get(stateRef.current.values, name))\n        : value;\n\n      if (!isUndefined(value)) {\n        setStateRef(`values.${name}`, value);\n      } else {\n        handleUnset(`values.${name}`);\n      }\n      setNodeValue(name, value);\n\n      isFieldArray(fieldArrayRef.current, name, (key) =>\n        fieldArrayRef.current[key].reset()\n      );\n\n      if (shouldTouched) setTouched(name, true, { shouldValidate: false });\n      if (shouldDirty) setDirtyIfNeeded(name);\n      if (shouldValidate) validateFieldWithLowPriority(name);\n    },\n    [\n      handleUnset,\n      setDirtyIfNeeded,\n      setNodeValue,\n      setStateRef,\n      setTouched,\n      stateRef,\n      validateFieldWithLowPriority,\n      validateOnChange,\n    ]\n  );\n\n  const getOptions = useCallback(\n    () => ({\n      getState,\n      setValue,\n      setTouched,\n      setDirty,\n      setError,\n      clearErrors,\n      runValidation,\n      removeField,\n      focus,\n      reset,\n      submit,\n    }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  const reset: Reset<V> = useCallback(\n    (values, exclude, e) => {\n      if (e?.preventDefault) e.preventDefault();\n      if (e?.stopPropagation) e.stopPropagation();\n\n      const state = { ...stateRef.current };\n      const skip = arrayToMap(exclude || []);\n\n      Object.keys(state).forEach((key) => {\n        if (skip[key]) return;\n\n        if (key === \"values\") {\n          const nextValues =\n            (isFunction(values) ? values(stateRef.current.values) : values) ||\n            initialStateRef.current.values;\n\n          state[key] = nextValues;\n          initialStateRef.current.values = nextValues;\n          setNodesOrValues(nextValues, {\n            shouldSetValues: false,\n            fields: Array.from(fieldsRef.current.keys()).filter(\n              (name) => !isFieldArray(fieldArrayRef.current, name)\n            ),\n          });\n        } else {\n          // @ts-expect-error\n          state[key] = initialStateRef.current[key];\n        }\n      });\n\n      setStateRef(\"\", state);\n      onResetRef.current(state.values, getOptions(), e);\n\n      Object.values(fieldArrayRef.current).forEach((field) => field.reset());\n    },\n    [getOptions, onResetRef, setNodesOrValues, setStateRef, stateRef]\n  );\n\n  const submit: Submit<V> = useCallback(\n    async (e) => {\n      if (e?.preventDefault) e.preventDefault();\n      if (e?.stopPropagation) e.stopPropagation();\n\n      const nextTouched = [\n        ...Array.from(fieldsRef.current.keys()),\n        ...Object.keys(controlsRef.current),\n      ].reduce((touched, name) => {\n        touched = set(touched, name, true, true);\n        return touched;\n      }, stateRef.current.touched);\n\n      setStateRef(\"touched\", nextTouched);\n      setStateRef(\"isSubmitted\", false);\n      setStateRef(\"isSubmitting\", true);\n\n      try {\n        const isValid = await runValidation();\n\n        if (!isValid) {\n          const { errors } = stateRef.current;\n\n          onErrorRef.current(errors, getOptions(), e);\n\n          if (focusOnError) {\n            let names = Array.isArray(focusOnError)\n              ? focusOnError\n              : Array.from(fieldsRef.current.keys());\n            names = isFunction(focusOnError) ? focusOnError(names) : names;\n            const name = names.find((n) => get(errors, n));\n\n            if (name) handleFocus(name);\n          }\n\n          return { errors };\n        }\n\n        await onSubmitRef.current(stateRef.current.values, getOptions(), e);\n        setStateRef(\"isSubmitted\", true);\n\n        return { values: stateRef.current.values };\n      } catch (exception) {\n        warn(`ðŸ’¡ react-cool-form > submit: `, exception);\n        throw exception;\n      } finally {\n        setStateRef(\"isSubmitting\", false);\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      getOptions,\n      handleFocus,\n      onErrorRef,\n      onSubmitRef,\n      runValidation,\n      setStateRef,\n      stateRef,\n    ]\n  );\n\n  const handleChangeEvent = useCallback<HandleChangeEvent>(\n    (name, value) => {\n      setStateRef(`values.${name}`, value);\n      setDirtyIfNeeded(name);\n\n      if (validateOnChange) validateFieldWithLowPriority(name);\n    },\n    [\n      setDirtyIfNeeded,\n      setStateRef,\n      validateFieldWithLowPriority,\n      validateOnChange,\n    ]\n  );\n\n  const shouldRemoveField = useCallback<ShouldRemoveField>(\n    (name) => {\n      if (!removeOnUnmounted) return false;\n\n      let names = Array.isArray(removeOnUnmounted)\n        ? removeOnUnmounted\n        : [\n            ...Array.from(fieldsRef.current.keys()),\n            ...Object.keys(controlsRef.current),\n            ...Object.keys(fieldArrayRef.current),\n          ];\n      names = isFunction(removeOnUnmounted) ? removeOnUnmounted(names) : names;\n\n      return names.includes(name);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  const removeField = useCallback<RemoveField>(\n    (name, exclude) => {\n      const { defaultValue, ...rest } = arrayToMap(exclude || [], {\n        value: \"values\",\n        error: \"errors\",\n      });\n\n      if (!defaultValue)\n        initialStateRef.current.values = unset(\n          initialStateRef.current.values,\n          name,\n          true\n        );\n\n      [\"values\", \"touched\", \"dirty\", \"errors\"].forEach((key, idx, arr) => {\n        const shouldForceUpdate = idx === arr.length - 1;\n\n        if (\n          !rest[key] &&\n          !isUndefined(get(stateRef.current[key as keyof FormState<V>], name))\n        )\n          handleUnset(`${key}.${name}`, {\n            shouldSkipUpdate: !shouldForceUpdate,\n            shouldForceUpdate,\n          });\n      });\n\n      delete fieldParsersRef.current[name];\n      delete fieldValidatorsRef.current[name];\n      delete fieldArrayRef.current[name];\n      delete controlsRef.current[name];\n\n      if (fieldsRef.current.has(name)) fieldsRef.current.delete(name);\n    },\n    [handleUnset, stateRef]\n  );\n\n  const registerForm = useCallback<RegisterForm>(\n    (el) => {\n      if (!el) return;\n\n      formRef.current = el;\n      const form = formRef.current;\n\n      fieldsRef.current = getFields(form);\n      setNodesOrValues(initialStateRef.current.values);\n\n      handlersRef.current.change = ({ target }: Event) => {\n        const { name } = target as FieldElement;\n\n        if (fieldsRef.current.has(name) && !controlsRef.current[name]) {\n          const parse = fieldParsersRef.current[name]?.parse;\n          const value = getNodeValue(name);\n\n          handleChangeEvent(name, parse ? parse(value) : value);\n          changedFieldRef.current = name;\n        }\n      };\n\n      handlersRef.current.blur = ({ target }: Event) => {\n        if (!isFieldElement(target as HTMLElement)) return;\n\n        const { name } = target as FieldElement;\n\n        if (fieldsRef.current.has(name) && !controlsRef.current[name]) {\n          setTouchedMaybeValidate(name);\n          changedFieldRef.current = undefined;\n        }\n      };\n\n      handlersRef.current.submit = (e: Event) => submit(e as any);\n\n      handlersRef.current.reset = (e: Event) => reset(null, null, e as any);\n\n      form.addEventListener(\"input\", handlersRef.current.change);\n      form.addEventListener(\"focusout\", handlersRef.current.blur);\n      form.addEventListener(\"submit\", handlersRef.current.submit);\n      form.addEventListener(\"reset\", handlersRef.current.reset);\n\n      mutationObserverRef.current = new MutationObserver(([{ type }]) => {\n        if (type !== \"childList\") return;\n\n        const fields = getFields(form);\n        let { values } = initialStateRef.current;\n\n        fieldsRef.current.forEach((_, name) => {\n          if (!shouldRemoveField(name)) return;\n          if (controlsRef.current[name]) return;\n\n          if (!fields.has(name)) {\n            removeField(\n              name,\n              !isFieldArray(fieldArrayRef.current, name) ||\n                isUndefined(\n                  get(initialStateRef.current.values, name.split(\".\")[0])\n                )\n                ? undefined\n                : [\"defaultValue\"]\n            );\n\n            return;\n          }\n\n          const currOptions = fieldsRef.current.get(name)?.options\n            ?.length as number;\n          const nextOptions = fields.get(name).options?.length as number;\n\n          if (currOptions > nextOptions) {\n            setStateRef(`values.${name}`, getNodeValue(name, fields), {\n              shouldSkipUpdate: true,\n            });\n          } else if (currOptions < nextOptions) {\n            setNodeValue(name, get(values, name), fields);\n          }\n        });\n\n        const addedNodes: string[] = [];\n\n        fields.forEach((_, name) => {\n          if (fieldsRef.current.has(name) || controlsRef.current[name]) return;\n\n          const value = get(stateRef.current.values, name);\n          if (!isUndefined(value)) values = set(values, name, value, true);\n\n          addedNodes.push(name);\n        });\n\n        fieldsRef.current = fields;\n        if (addedNodes.length) setNodesOrValues(values, { fields: addedNodes });\n      });\n\n      mutationObserverRef.current.observe(form, {\n        childList: true,\n        subtree: true,\n      });\n    },\n    [\n      getFields,\n      getNodeValue,\n      handleChangeEvent,\n      removeField,\n      reset,\n      setNodeValue,\n      setNodesOrValues,\n      setStateRef,\n      setTouchedMaybeValidate,\n      shouldRemoveField,\n      stateRef,\n      submit,\n    ]\n  );\n\n  const registerField = useCallback<RegisterField<V>>(\n    (value) => (field) => {\n      if (\n        !field?.name ||\n        controlsRef.current[field.name] ||\n        excludeFieldsRef.current[field.name]\n      )\n        return;\n\n      if (isFunction(value)) {\n        fieldValidatorsRef.current[field.name] = value;\n        return;\n      }\n\n      const { validate: validator, ...parsers } = value;\n\n      if (validator) fieldValidatorsRef.current[field.name] = validator;\n      fieldParsersRef.current[field.name] = parsers;\n    },\n    []\n  );\n\n  shared.set(id, {\n    validateOnChange,\n    shouldRemoveField,\n    initialStateRef,\n    fieldArrayRef,\n    controlsRef,\n    observersRef,\n    fieldValidatorsRef,\n    changedFieldRef,\n    setStateRef,\n    getNodeValue,\n    getFormState,\n    setDefaultValue,\n    setNodesOrValues,\n    setTouchedMaybeValidate,\n    handleChangeEvent,\n    removeField,\n    form: registerForm,\n    field: registerField,\n    focus,\n    use,\n    getState,\n    setValue,\n    setTouched,\n    setDirty,\n    setError,\n    clearErrors,\n    runValidation,\n    reset,\n    submit,\n  });\n\n  useEffect(\n    () => () => {\n      if (formRef.current) {\n        const handlers = handlersRef.current as Required<Handlers>;\n\n        formRef.current.removeEventListener(\"input\", handlers.change);\n        formRef.current.removeEventListener(\"focusout\", handlers.blur);\n        formRef.current.removeEventListener(\"submit\", handlers.submit);\n        formRef.current.removeEventListener(\"reset\", handlers.reset);\n        mutationObserverRef.current?.disconnect();\n      }\n\n      shared.remove(id);\n    },\n    [id]\n  );\n\n  return {\n    form: registerForm,\n    field: registerField,\n    focus,\n    removeField,\n    use,\n    getState,\n    setValue,\n    setTouched,\n    setDirty,\n    setError,\n    clearErrors,\n    runValidation,\n    reset,\n    submit,\n  };\n};\n","import { FormMethods, FormValues, Methods } from \"./types\";\nimport { get } from \"./shared\";\nimport { invariant } from \"./utils\";\n\nexport default <V extends FormValues = FormValues>(\n  formId?: string\n): FormMethods<V> => {\n  const methods: Methods<V> = get(formId);\n\n  invariant(\n    !methods,\n    'ðŸ’¡ react-cool-form > useFormMethods: It must work with an \"useForm\" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form'\n  );\n\n  const {\n    form,\n    field,\n    focus,\n    removeField,\n    use,\n    getState,\n    setValue,\n    setTouched,\n    setDirty,\n    setError,\n    clearErrors,\n    runValidation,\n    reset,\n    submit,\n  } = methods;\n\n  return {\n    form,\n    field,\n    focus,\n    removeField,\n    use,\n    getState,\n    setValue,\n    setTouched,\n    setDirty,\n    setError,\n    clearErrors,\n    runValidation,\n    reset,\n    submit,\n  };\n};\n","/* eslint-disable react-hooks/rules-of-hooks */\n\nimport { useEffect, useReducer, useRef } from \"react\";\n\nimport {\n  FormStateCallback,\n  FormStateConfig,\n  FormValues,\n  Methods,\n  Observer,\n  Path,\n} from \"./types\";\nimport { get } from \"./shared\";\nimport { invariant, isFunction, parseState } from \"./utils\";\n\nexport default <V extends FormValues = FormValues>(\n  path: Path,\n  configOrCallback: FormStateCallback | FormStateConfig<V>,\n  formId?: string\n): any => {\n  const config = !isFunction(configOrCallback) ? configOrCallback : {};\n  const methods: Methods<V> = get(config?.formId || formId);\n\n  invariant(\n    !methods,\n    `ðŸ’¡ react-cool-form > useFormState: It must work with an \"useForm\" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form`\n  );\n\n  const observerRef = useRef<Observer<V>>();\n  const [, forceUpdate] = useReducer((c) => c + 1, 0);\n  const { observersRef, getFormState } = methods;\n  const callback = isFunction(configOrCallback) ? configOrCallback : undefined;\n\n  useEffect(() => {\n    observersRef.current.push(observerRef.current!);\n\n    return () => {\n      observersRef.current = observersRef.current.filter(\n        (o) => o !== observerRef.current\n      );\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return getFormState(path, {\n    ...config,\n    methodName: callback ? \"useFormStateCallback\" : \"useFormState\",\n    callback: (usedState) => {\n      if (!observerRef.current)\n        observerRef.current = {\n          usedState,\n          notify: callback\n            ? (state) => callback(parseState(path, state))\n            : forceUpdate,\n        };\n    },\n  });\n};\n","import { useEffect } from \"react\";\n\nimport {\n  ControlledConfig,\n  ControlledReturn,\n  FormValues,\n  Methods,\n} from \"./types\";\nimport * as shared from \"./shared\";\nimport {\n  get,\n  invariant,\n  isFieldArray,\n  isFieldElement,\n  isUndefined,\n  warn,\n} from \"./utils\";\nimport useFormState from \"./useFormState\";\n\nexport default <V extends FormValues = FormValues>(\n  name: string,\n  {\n    formId,\n    defaultValue,\n    validate,\n    parse,\n    format,\n    errorWithTouched,\n    ...props\n  }: ControlledConfig<V> = {}\n): ControlledReturn => {\n  const methods: Methods<V> = shared.get(formId);\n\n  invariant(\n    !methods,\n    'ðŸ’¡ react-cool-form > useControlled: It must work with an \"useForm\" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form'\n  );\n\n  const meta = useFormState(\n    {\n      value: `values.${name}`,\n      error: `errors.${name}`,\n      isTouched: `touched.${name}`,\n      isDirty: `dirty.${name}`,\n    },\n    { formId, errorWithTouched }\n  );\n  const {\n    shouldRemoveField,\n    initialStateRef,\n    fieldArrayRef,\n    controlsRef,\n    fieldValidatorsRef,\n    changedFieldRef,\n    getState,\n    getNodeValue,\n    setDefaultValue,\n    setTouchedMaybeValidate,\n    handleChangeEvent,\n    removeField,\n  } = methods;\n\n  useEffect(\n    () => {\n      const isFieldArr = isFieldArray(fieldArrayRef.current, name);\n      const initialVal = get(initialStateRef.current.values, name);\n\n      if (isUndefined(initialVal)) {\n        if (\n          !isUndefined(defaultValue) &&\n          (!isFieldArr ||\n            !isUndefined(\n              get(initialStateRef.current.values, name.split(\".\")[0])\n            ))\n        ) {\n          setDefaultValue(name, defaultValue);\n        } else if (!isFieldArr) {\n          warn(\n            `ðŸ’¡ react-cool-form > useControlled: Please provide a default value for \"${name}\" field.`\n          );\n        }\n      } else if (isUndefined(getState(name))) {\n        setDefaultValue(name, initialVal);\n      }\n\n      return () => {\n        if (shouldRemoveField(name))\n          removeField(\n            name,\n            !isFieldArr ||\n              isUndefined(\n                // eslint-disable-next-line react-hooks/exhaustive-deps\n                get(initialStateRef.current.values, name.split(\".\")[0])\n              )\n              ? undefined\n              : [\"defaultValue\"]\n          );\n      };\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  controlsRef.current[name] = true;\n  if (validate) fieldValidatorsRef.current[name] = validate;\n\n  const { onChange, onBlur, ...restProps } = props;\n  let value = get(initialStateRef.current.values, name);\n  value = !isUndefined(value) ? value : defaultValue;\n  value = !isUndefined(meta.value) ? meta.value : value;\n  value = (format ? format(value) : value) ?? \"\";\n\n  return [\n    {\n      name,\n      value,\n      onChange: (...event) => {\n        let val;\n\n        if (parse) {\n          val = parse(...event);\n        } else {\n          const e = event[0];\n          val =\n            e?.nativeEvent instanceof Event && isFieldElement(e.target)\n              ? getNodeValue(name)\n              : e;\n        }\n\n        handleChangeEvent(name, val);\n        if (onChange) onChange(...event);\n        changedFieldRef.current = name;\n      },\n      onBlur: (e) => {\n        setTouchedMaybeValidate(name);\n        if (onBlur) onBlur(e);\n        changedFieldRef.current = undefined;\n      },\n      ...restProps,\n    },\n    { error: meta.error, isTouched: !!meta.isTouched, isDirty: !!meta.isDirty },\n  ];\n};\n","import { useCallback, useEffect, useState } from \"react\";\n\nimport {\n  FieldArrayConfig,\n  FieldArrayReturn,\n  FormValues,\n  Insert,\n  Keys,\n  Methods,\n  Move,\n  Push,\n  Remove,\n  StateHandler,\n  Swap,\n} from \"./types\";\nimport * as shared from \"./shared\";\nimport {\n  compact,\n  get,\n  getIsDirty,\n  invariant,\n  isUndefined,\n  set,\n  setValuesAsTrue,\n} from \"./utils\";\n\nexport default <T = any, V extends FormValues = FormValues>(\n  name: string,\n  { formId, defaultValue, validate }: FieldArrayConfig<T, V> = {}\n): FieldArrayReturn<T> => {\n  const methods: Methods<V> = shared.get(formId);\n\n  invariant(\n    !methods,\n    'ðŸ’¡ react-cool-form > useFieldArray: It must work with an \"useForm\" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form'\n  );\n\n  const {\n    validateOnChange,\n    shouldRemoveField,\n    initialStateRef,\n    fieldArrayRef,\n    fieldValidatorsRef,\n    getState,\n    setDefaultValue,\n    setNodesOrValues,\n    setStateRef,\n    runValidation,\n    removeField,\n  } = methods;\n\n  const getFields = useCallback(\n    (init = false): string[] => {\n      let fields = getState(name);\n\n      if (init && isUndefined(fields)) fields = defaultValue;\n\n      return Array.isArray(fields)\n        ? fields.map((_, index) => `${name}[${index}]`)\n        : [];\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [getState, name]\n  );\n\n  const [fields, setFields] = useState<string[]>(getFields(true));\n\n  const updateFields = useCallback(() => {\n    setFields(getFields());\n    setNodesOrValues(getState(\"values\"), {\n      shouldSetValues: false,\n      fields: Object.keys(fieldArrayRef.current[name].fields),\n    });\n  }, [fieldArrayRef, getFields, getState, name, setNodesOrValues]);\n\n  useEffect(() => {\n    if (\n      isUndefined(get(initialStateRef.current.values, name)) &&\n      !isUndefined(defaultValue)\n    ) {\n      setDefaultValue(name, defaultValue, true);\n      updateFields();\n    }\n\n    return () => {\n      if (shouldRemoveField(name)) removeField(name);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  if (!fieldArrayRef.current[name])\n    fieldArrayRef.current[name] = {\n      reset: updateFields,\n      fields: {},\n    };\n  if (validate) fieldValidatorsRef.current[name] = validate;\n\n  const setState = useCallback(\n    (\n      handler: StateHandler,\n      {\n        shouldTouched,\n        shouldDirty,\n      }: { shouldTouched?: boolean; shouldDirty?: boolean } = {}\n    ) => {\n      let state = getState();\n\n      ([\"values\", \"touched\", \"errors\", \"dirty\"] as Keys[]).forEach((key) => {\n        const value = state[key][name];\n        const fieldsLength = state.values[name]?.length;\n\n        if (\n          key === \"values\" ||\n          (key === \"touched\" && shouldTouched) ||\n          (key === \"dirty\" && shouldDirty) ||\n          !isUndefined(value)\n        )\n          state = set(\n            state,\n            key,\n            {\n              ...state[key],\n              [name]: handler(\n                Array.isArray(value) ? [...value] : [],\n                key,\n                fieldsLength ? fieldsLength - 1 : 0\n              ),\n            },\n            true\n          );\n      });\n\n      setStateRef(\"\", { ...state, shouldDirty: getIsDirty(state.dirty) });\n      updateFields();\n\n      if (validateOnChange) runValidation(name);\n    },\n    [getState, name, runValidation, setStateRef, updateFields, validateOnChange]\n  );\n\n  const push = useCallback<Push<T>>(\n    (value, { shouldTouched, shouldDirty = true } = {}) => {\n      const handler: StateHandler = (f, type, lastIndex = 0) => {\n        if (type === \"values\") {\n          f.push(value);\n        } else if (\n          (type === \"touched\" && shouldTouched) ||\n          (type === \"dirty\" && shouldDirty)\n        ) {\n          f[lastIndex] = setValuesAsTrue(value);\n        }\n\n        return f;\n      };\n\n      setState(handler, { shouldTouched, shouldDirty });\n    },\n    [setState]\n  );\n\n  const insert = useCallback<Insert<T>>(\n    (index, value, { shouldTouched, shouldDirty = true } = {}) => {\n      const handler: StateHandler = (f, type) => {\n        if (type === \"values\") {\n          f.splice(index, 0, value);\n        } else if (\n          (type === \"touched\" && shouldTouched) ||\n          (type === \"dirty\" && shouldDirty)\n        ) {\n          f[index] = setValuesAsTrue(value);\n        } else if (index < f.length) {\n          f.splice(index, 0, undefined);\n        }\n\n        return f;\n      };\n\n      setState(handler, { shouldTouched, shouldDirty });\n    },\n    [setState]\n  );\n\n  const remove = useCallback<Remove<T>>(\n    (index) => {\n      const handler: StateHandler = (f) => {\n        f.splice(index, 1);\n        return compact(f).length ? f : [];\n      };\n      const value = (getState(name) || [])[index];\n\n      setState(handler);\n\n      return value;\n    },\n    [getState, name, setState]\n  );\n\n  const swap = useCallback<Swap>(\n    (indexA, indexB) => {\n      const handler: StateHandler = (f) => {\n        [f[indexA], f[indexB]] = [f[indexB], f[indexA]];\n        return f;\n      };\n\n      setState(handler);\n    },\n    [setState]\n  );\n\n  const move = useCallback<Move>(\n    (from, to) => {\n      const handler: StateHandler = (f) => {\n        f.splice(to, 0, f.splice(from, 1)[0]);\n        return f;\n      };\n\n      setState(handler);\n    },\n    [setState]\n  );\n\n  return [fields, { push, insert, remove, swap, move }];\n};\n"]},"metadata":{},"sourceType":"module"}